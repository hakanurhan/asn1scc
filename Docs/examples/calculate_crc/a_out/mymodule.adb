-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
WITH adaasn1rtl.encoding;
WITH adaasn1rtl.encoding.uper;
WITH adaasn1rtl.encoding.acn;
WITH postEncoding;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY MYMODULE with SPARK_Mode IS




function PacketHeader_version_Equal(val1, val2: in PacketHeader_version)
    return Boolean 
is
begin
	return val1 = val2;

end PacketHeader_version_Equal;

function PacketHeader_release_Equal(val1, val2: in PacketHeader_release)
    return Boolean 
is
begin
	return val1 = val2;

end PacketHeader_release_Equal;

function PacketHeader_varSizeArray_elem_Equal(val1, val2: in PacketHeader_varSizeArray_elem)
    return Boolean 
is
begin
	return val1 = val2;

end PacketHeader_varSizeArray_elem_Equal;

function PacketHeader_varSizeArray_Equal(val1, val2: in PacketHeader_varSizeArray)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := PacketHeader_varSizeArray_elem_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end PacketHeader_varSizeArray_Equal;

function PacketHeader_Equal(val1, val2: in PacketHeader)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := PacketHeader_version_Equal(val1.version, val2.version);
    
    if ret then
        ret := PacketHeader_release_Equal(val1.release, val2.release);
        
        if ret then
            ret := PacketHeader_varSizeArray_Equal(val1.varSizeArray, val2.varSizeArray);
        
        end if;
    end if;
	return ret;

end PacketHeader_Equal;

function PacketHeader_version_Init return PacketHeader_version
is
    val: PacketHeader_version;
begin
    val := 1;
    return val;
end PacketHeader_version_Init;
function PacketHeader_release_Init return PacketHeader_release
is
    val: PacketHeader_release;
begin
    val := 1;
    return val;
end PacketHeader_release_Init;
function PacketHeader_varSizeArray_elem_Init return PacketHeader_varSizeArray_elem
is
    val: PacketHeader_varSizeArray_elem;
begin
    val := 1;
    return val;
end PacketHeader_varSizeArray_elem_Init;
function PacketHeader_varSizeArray_Init return PacketHeader_varSizeArray
is
    val: PacketHeader_varSizeArray;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 20 loop
        pragma Loop_Invariant (i1 >=1 and i1<=20);
        val.Data(i1) := PacketHeader_varSizeArray_elem_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end PacketHeader_varSizeArray_Init;
function PacketHeader_Init return PacketHeader
is
    val: PacketHeader;
begin

    --set version 
    val.version := PacketHeader_version_Init;
    --set release 
    val.release := PacketHeader_release_Init;
    --set varSizeArray 
    val.varSizeArray := PacketHeader_varSizeArray_Init;
    return val;
end PacketHeader_Init;

FUNCTION PacketHeader_IsConstraintValid(val : in PacketHeader) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret.Success := ((1 <= val.version) AND (val.version <= 100));
    ret.ErrorCode := (if ret.Success then 0 else ERR_PACKETHEADER_VERSION);
    if ret.Success then
        ret.Success := ((1 <= val.release) AND (val.release <= 100));
        ret.ErrorCode := (if ret.Success then 0 else ERR_PACKETHEADER_RELEASE);
        if ret.Success then
            ret.Success := ((1 <= val.varSizeArray.Length) AND (val.varSizeArray.Length <= 20));
            ret.ErrorCode := (if ret.Success then 0 else ERR_PACKETHEADER_VARSIZEARRAY);
            if ret.Success then
                i1 := val.varSizeArray.Data'First;
                while ret.Success and i1 <= val.varSizeArray.Length loop
                    pragma Loop_Invariant (i1 >= val.varSizeArray.Data'First and i1 <= val.varSizeArray.Length);
                    ret.Success := ((1 <= val.varSizeArray.Data(i1)) AND (val.varSizeArray.Data(i1) <= 20));
                    ret.ErrorCode := (if ret.Success then 0 else ERR_PACKETHEADER_VARSIZEARRAY_ELM);
                    i1 := i1+1;
                end loop;
            end if;
        end if;
    end if;
    RETURN ret;
END PacketHeader_IsConstraintValid;

procedure PacketHeader_ACN_Encode_aux(val:in PacketHeader; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
    i1:Integer;
BEGIN
    result := PacketHeader_IsConstraintValid(val);
    IF result.success THEN
        -- Encode version 
        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val.version, 1, 7);
        if result.Success then
            -- Encode release 
            adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val.release, 1, 7);
            if result.Success then
                -- Encode varSizeArray 
                result.Success := val.varSizeArray.Length >= 1 AND val.varSizeArray.Length <= 20;
                result.errorCode := ERR_ACN_ENCODE_PACKETHEADER_VARSIZEARRAY;
                i1 := 1; 
                if result.Success THEN
                    adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, adaasn1rtl.Asn1Int(val.varSizeArray.Length), 1, 5);
                        
                    while i1<= val.varSizeArray.Length loop
                        pragma Loop_Invariant (i1 >=1 and i1<=val.varSizeArray.Length);
                        --pragma Loop_Invariant (K >= K'Loop_Entry);
                        --pragma Loop_Invariant (K<=K'Loop_Entry + 5*(i1-1));
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val.varSizeArray.Data(i1), 1, 5);
                        i1 := i1 + 1;
                    end loop;
                end if;
            end if;
        end if;
    END IF;
END PacketHeader_ACN_Encode_aux;


PROCEDURE PacketHeader_ACN_Encode(val:in PacketHeader; Stream : out PacketHeader_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
BEGIN
    Stream := PacketHeader_ACN_Stream'(Size_In_Bytes => PacketHeader_REQUIRED_BYTES_FOR_ACN_ENCODING, Current_Bit_Pos  => 0, Buffer => (others => 0));
    PacketHeader_ACN_Encode_aux(val, Stream, result);
END PacketHeader_ACN_Encode;

pragma Warnings (Off, "unused initial value of ""val""");
PROCEDURE PacketHeader_ACN_Decode_aux(val:out PacketHeader; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
    i1:Integer;
    nStringLength:Integer;
BEGIN
    -- Decode version 
    result.ErrorCode := ERR_ACN_DECODE_PACKETHEADER_VERSION;
    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, val.version, 1, 100, 7, result.Success);
    if result.Success then
        -- Decode release 
        result.ErrorCode := ERR_ACN_DECODE_PACKETHEADER_RELEASE;
        adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, val.release, 1, 100, 7, result.Success);
        if result.Success then
            -- Decode varSizeArray 
            adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, nStringLength, 1, 20, 5, result.Success);
            result.errorCode := ERR_ACN_DECODE_PACKETHEADER_VARSIZEARRAY;
            i1 := 1; 
            val.varSizeArray.Length := nStringLength;
                
            while i1<= val.varSizeArray.Length AND result.Success loop
                pragma Loop_Invariant (i1 >=1 and i1<=val.varSizeArray.Length);
                --pragma Loop_Invariant (K.K >= K'Loop_Entry.K);
                --pragma Loop_Invariant (K.K <= K'Loop_Entry.K + 5*(i1-1));
                result.ErrorCode := ERR_ACN_DECODE_PACKETHEADER_VARSIZEARRAY_ELM;
                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, val.varSizeArray.Data(i1), 1, 20, 5, result.Success);
                i1 := i1 + 1;
            end loop;
        end if;
    end if;
END PacketHeader_ACN_Decode_aux;
pragma Warnings (On, "unused initial value of ""val""");

PROCEDURE PacketHeader_ACN_Decode(val: out PacketHeader; Stream : in out PacketHeader_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
BEGIN
    Stream.Current_Bit_Pos :=0;
    PacketHeader_ACN_Decode_aux(val, Stream, result);
    if result.success then
        result := PacketHeader_IsConstraintValid(val);
    end if;

END PacketHeader_ACN_Decode;



function PacketBody_anInteger_Equal(val1, val2: in PacketBody_anInteger)
    return Boolean 
is
begin
	return val1 = val2;

end PacketBody_anInteger_Equal;

function PacketBody_anotherSizeArray_elem_Equal(val1, val2: in PacketBody_anotherSizeArray_elem)
    return Boolean 
is
begin
	return val1 = val2;

end PacketBody_anotherSizeArray_elem_Equal;

function PacketBody_anotherSizeArray_Equal(val1, val2: in PacketBody_anotherSizeArray)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := PacketBody_anotherSizeArray_elem_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end PacketBody_anotherSizeArray_Equal;

function PacketBody_Equal(val1, val2: in PacketBody)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when aReal_PRESENT =>
                ret := (adaasn1rtl.Asn1Real_Equal(val1.aReal, val2.aReal));
            when anInteger_PRESENT =>
                ret := PacketBody_anInteger_Equal(val1.anInteger, val2.anInteger);
            when anotherSizeArray_PRESENT =>
                ret := PacketBody_anotherSizeArray_Equal(val1.anotherSizeArray, val2.anotherSizeArray);
        end case;
    end if;
	return ret;

end PacketBody_Equal;

function PacketBody_anInteger_Init return PacketBody_anInteger
is
    val: PacketBody_anInteger;
begin
    val := 0;
    return val;
end PacketBody_anInteger_Init;
function PacketBody_anotherSizeArray_elem_Init return PacketBody_anotherSizeArray_elem
is
    val: PacketBody_anotherSizeArray_elem;
begin
    val := 1;
    return val;
end PacketBody_anotherSizeArray_elem_Init;
function PacketBody_anotherSizeArray_Init return PacketBody_anotherSizeArray
is
    val: PacketBody_anotherSizeArray;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := PacketBody_anotherSizeArray_elem_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end PacketBody_anotherSizeArray_Init;
function PacketBody_Init return PacketBody
is
    val: PacketBody;
begin
    --set aReal 
    declare
        aReal_tmp:adaasn1rtl.Asn1Real;
    begin
        aReal_tmp := 0.00000000000000000000E+000;
        val := PacketBody'(kind => aReal_PRESENT, aReal => aReal_tmp);
    end;
    return val;
end PacketBody_Init;

FUNCTION PacketBody_IsConstraintValid(val : in PacketBody) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    if val.kind = anInteger_PRESENT then
    	ret.Success := (val.anInteger <= 65535);
    	ret.ErrorCode := (if ret.Success then 0 else ERR_PACKETBODY_ANINTEGER);
    end if;
    if ret.Success then
        if val.kind = anotherSizeArray_PRESENT then
        	ret.Success := ((1 <= val.anotherSizeArray.Length) AND (val.anotherSizeArray.Length <= 100));
        	ret.ErrorCode := (if ret.Success then 0 else ERR_PACKETBODY_ANOTHERSIZEARRAY);
        	if ret.Success then
        	    i1 := val.anotherSizeArray.Data'First;
        	    while ret.Success and i1 <= val.anotherSizeArray.Length loop
        	        pragma Loop_Invariant (i1 >= val.anotherSizeArray.Data'First and i1 <= val.anotherSizeArray.Length);
        	        ret.Success := ((1 <= val.anotherSizeArray.Data(i1)) AND (val.anotherSizeArray.Data(i1) <= 200));
        	        ret.ErrorCode := (if ret.Success then 0 else ERR_PACKETBODY_ANOTHERSIZEARRAY_ELM);
        	        i1 := i1+1;
        	    end loop;
        	end if;
        end if;
    end if;
    RETURN ret;
END PacketBody_IsConstraintValid;

procedure PacketBody_ACN_Encode_aux(val:in PacketBody; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
    i1:Integer;
BEGIN
    result := PacketBody_IsConstraintValid(val);
    IF result.success THEN
        case val.kind IS
            when aReal_PRESENT =>
                adaasn1rtl.encoding.Enc_ConstraintWholeNumber(bs, 0, 0, 2);
            	adaasn1rtl.encoding.uper.UPER_Enc_Real(bs, val.aReal);
            when anInteger_PRESENT =>
                adaasn1rtl.encoding.Enc_ConstraintWholeNumber(bs, 1, 0, 2);
            	adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val.anInteger, 0, 16);
            when anotherSizeArray_PRESENT =>
                adaasn1rtl.encoding.Enc_ConstraintWholeNumber(bs, 2, 0, 2);
            	result.Success := val.anotherSizeArray.Length >= 1 AND val.anotherSizeArray.Length <= 100;
            	result.errorCode := ERR_ACN_ENCODE_PACKETBODY_ANOTHERSIZEARRAY;
            	i1 := 1; 
            	if result.Success THEN
            	    adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, adaasn1rtl.Asn1Int(val.anotherSizeArray.Length), 1, 7);
            	        
            	    while i1<= val.anotherSizeArray.Length loop
            	        pragma Loop_Invariant (i1 >=1 and i1<=val.anotherSizeArray.Length);
            	        --pragma Loop_Invariant (K >= K'Loop_Entry);
            	        --pragma Loop_Invariant (K<=K'Loop_Entry + 8*(i1-1));
            	        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val.anotherSizeArray.Data(i1), 1, 8);
            	        i1 := i1 + 1;
            	    end loop;
            	end if;
        end case;
    END IF;
END PacketBody_ACN_Encode_aux;


PROCEDURE PacketBody_ACN_Encode(val:in PacketBody; Stream : out PacketBody_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
BEGIN
    Stream := PacketBody_ACN_Stream'(Size_In_Bytes => PacketBody_REQUIRED_BYTES_FOR_ACN_ENCODING, Current_Bit_Pos  => 0, Buffer => (others => 0));
    PacketBody_ACN_Encode_aux(val, Stream, result);
END PacketBody_ACN_Encode;

pragma Warnings (Off, "unused initial value of ""val""");
PROCEDURE PacketBody_ACN_Decode_aux(val:out PacketBody; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
    MYMODULE_PacketBody_index_tmp:adaasn1rtl.Asn1Int;
    i1:Integer;
    nStringLength:Integer;
BEGIN
    result.ErrorCode := ERR_ACN_DECODE_PACKETBODY;
    adaasn1rtl.encoding.Dec_ConstraintWholeNumber(bs, MYMODULE_PacketBody_index_tmp, 0, 2, 2, result.Success);
    if result.Success AND MYMODULE_PacketBody_index_tmp >= 0 AND  MYMODULE_PacketBody_index_tmp <= 2 THEN
        case PacketBody_index_range(MYMODULE_PacketBody_index_tmp) IS
            when 0 =>
              declare
                 aReal_tmp:adaasn1rtl.Asn1Real;
              begin
                adaasn1rtl.encoding.uper.UPER_Dec_Real(bs, aReal_tmp, result);
                if result.Success then
                    val := PacketBody'(kind => aReal_PRESENT, aReal => aReal_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
            when 1 =>
              declare
                 anInteger_tmp:PacketBody_anInteger;
              begin
                result.ErrorCode := ERR_ACN_DECODE_PACKETBODY_ANINTEGER;
                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, anInteger_tmp, 0, 65535, 16, result.Success);
                if result.Success then
                    val := PacketBody'(kind => anInteger_PRESENT, anInteger => anInteger_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
            when 2 =>
              declare
                 anotherSizeArray_tmp:PacketBody_anotherSizeArray;
              begin
                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, nStringLength, 1, 100, 7, result.Success);
                result.errorCode := ERR_ACN_DECODE_PACKETBODY_ANOTHERSIZEARRAY;
                i1 := 1; 
                anotherSizeArray_tmp.Length := nStringLength;
                    
                while i1<= anotherSizeArray_tmp.Length AND result.Success loop
                    pragma Loop_Invariant (i1 >=1 and i1<=anotherSizeArray_tmp.Length);
                    --pragma Loop_Invariant (K.K >= K'Loop_Entry.K);
                    --pragma Loop_Invariant (K.K <= K'Loop_Entry.K + 8*(i1-1));
                    result.ErrorCode := ERR_ACN_DECODE_PACKETBODY_ANOTHERSIZEARRAY_ELM;
                    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, anotherSizeArray_tmp.Data(i1), 1, 200, 8, result.Success);
                    i1 := i1 + 1;
                end loop;
                if result.Success then
                    val := PacketBody'(kind => anotherSizeArray_PRESENT, anotherSizeArray => anotherSizeArray_tmp);
                    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                end if;
              end;
        end case;
    end if;
END PacketBody_ACN_Decode_aux;
pragma Warnings (On, "unused initial value of ""val""");

PROCEDURE PacketBody_ACN_Decode(val: out PacketBody; Stream : in out PacketBody_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
BEGIN
    Stream.Current_Bit_Pos :=0;
    PacketBody_ACN_Decode_aux(val, Stream, result);
    if result.success then
        result := PacketBody_IsConstraintValid(val);
    end if;

END PacketBody_ACN_Decode;



function Packet_Equal(val1, val2: in Packet)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := PacketHeader_Equal(val1.p_header, val2.p_header);
    
    if ret then
        ret := PacketBody_Equal(val1.p_body, val2.p_body);
    
    end if;
	return ret;

end Packet_Equal;

function Packet_Init return Packet
is
    val: Packet;
begin

    --set p_header 
    val.p_header := PacketHeader_Init;
    --set p_body 
    val.p_body := PacketBody_Init;
    return val;
end Packet_Init;

FUNCTION Packet_IsConstraintValid(val : in Packet) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret.Success := ((1 <= val.p_header.version) AND (val.p_header.version <= 100));
    ret.ErrorCode := (if ret.Success then 0 else ERR_PACKET_P_HEADER_VERSION);
    if ret.Success then
        ret.Success := ((1 <= val.p_header.release) AND (val.p_header.release <= 100));
        ret.ErrorCode := (if ret.Success then 0 else ERR_PACKET_P_HEADER_RELEASE);
        if ret.Success then
            ret.Success := ((1 <= val.p_header.varSizeArray.Length) AND (val.p_header.varSizeArray.Length <= 20));
            ret.ErrorCode := (if ret.Success then 0 else ERR_PACKET_P_HEADER_VARSIZEARRAY);
            if ret.Success then
                i1 := val.p_header.varSizeArray.Data'First;
                while ret.Success and i1 <= val.p_header.varSizeArray.Length loop
                    pragma Loop_Invariant (i1 >= val.p_header.varSizeArray.Data'First and i1 <= val.p_header.varSizeArray.Length);
                    ret.Success := ((1 <= val.p_header.varSizeArray.Data(i1)) AND (val.p_header.varSizeArray.Data(i1) <= 20));
                    ret.ErrorCode := (if ret.Success then 0 else ERR_PACKET_P_HEADER_VARSIZEARRAY_ELM);
                    i1 := i1+1;
                end loop;
            end if;
        end if;
    end if;
    if ret.Success then
        if val.p_body.kind = anInteger_PRESENT then
        	ret.Success := (val.p_body.anInteger <= 65535);
        	ret.ErrorCode := (if ret.Success then 0 else ERR_PACKET_P_BODY_ANINTEGER);
        end if;
        if ret.Success then
            if val.p_body.kind = anotherSizeArray_PRESENT then
            	ret.Success := ((1 <= val.p_body.anotherSizeArray.Length) AND (val.p_body.anotherSizeArray.Length <= 100));
            	ret.ErrorCode := (if ret.Success then 0 else ERR_PACKET_P_BODY_ANOTHERSIZEARRAY);
            	if ret.Success then
            	    i1 := val.p_body.anotherSizeArray.Data'First;
            	    while ret.Success and i1 <= val.p_body.anotherSizeArray.Length loop
            	        pragma Loop_Invariant (i1 >= val.p_body.anotherSizeArray.Data'First and i1 <= val.p_body.anotherSizeArray.Length);
            	        ret.Success := ((1 <= val.p_body.anotherSizeArray.Data(i1)) AND (val.p_body.anotherSizeArray.Data(i1) <= 200));
            	        ret.ErrorCode := (if ret.Success then 0 else ERR_PACKET_P_BODY_ANOTHERSIZEARRAY_ELM);
            	        i1 := i1+1;
            	    end loop;
            	end if;
            end if;
        end if;
    end if;
    RETURN ret;
END Packet_IsConstraintValid;

procedure Packet_ACN_Encode_aux(val:in Packet; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
    bitStreamPositions_1:Packet_extension_function_positions;
    bitStreamPositions_start1:adaasn1rtl.encoding.BitStreamPtr;
    i1:Integer;
BEGIN
    result := Packet_IsConstraintValid(val);
    IF result.success THEN
        bitStreamPositions_start1.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
        bitStreamPositions_start1.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
        if result.Success then
            -- Encode p_header 
            -- Encode version 
            adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val.p_header.version, 1, 7);
            if result.Success then
                -- Encode release 
                adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val.p_header.release, 1, 7);
                if result.Success then
                    -- Encode varSizeArray 
                    result.Success := val.p_header.varSizeArray.Length >= 1 AND val.p_header.varSizeArray.Length <= 20;
                    result.errorCode := ERR_ACN_ENCODE_PACKET_P_HEADER_VARSIZEARRAY;
                    i1 := 1; 
                    if result.Success THEN
                        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, adaasn1rtl.Asn1Int(val.p_header.varSizeArray.Length), 1, 5);
                            
                        while i1<= val.p_header.varSizeArray.Length loop
                            pragma Loop_Invariant (i1 >=1 and i1<=val.p_header.varSizeArray.Length);
                            --pragma Loop_Invariant (K >= K'Loop_Entry);
                            --pragma Loop_Invariant (K<=K'Loop_Entry + 5*(i1-1));
                            adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val.p_header.varSizeArray.Data(i1), 1, 5);
                            i1 := i1 + 1;
                        end loop;
                    end if;
                end if;
            end if;
            if result.Success then
                -- Encode Packet_body_length_in_bytes 
                bitStreamPositions_1.Packet_body_length_in_bytes.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
                bitStreamPositions_1.Packet_body_length_in_bytes.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
                adaasn1rtl.encoding.acn.Acn_Enc_NullType_pattern2(bs, BitArray'(1=>0,2=>0,3=>0,4=>0,5=>0,6=>0,7=>0,8=>0,9=>0,10=>0,11=>0,12=>0,13=>0,14=>0,15=>0,16=>0));
                if result.Success then
                    -- Encode p_body 
                    case val.p_body.kind IS
                        when aReal_PRESENT =>
                            adaasn1rtl.encoding.Enc_ConstraintWholeNumber(bs, 0, 0, 2);
                        	adaasn1rtl.encoding.uper.UPER_Enc_Real(bs, val.p_body.aReal);
                        when anInteger_PRESENT =>
                            adaasn1rtl.encoding.Enc_ConstraintWholeNumber(bs, 1, 0, 2);
                        	adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val.p_body.anInteger, 0, 16);
                        when anotherSizeArray_PRESENT =>
                            adaasn1rtl.encoding.Enc_ConstraintWholeNumber(bs, 2, 0, 2);
                        	result.Success := val.p_body.anotherSizeArray.Length >= 1 AND val.p_body.anotherSizeArray.Length <= 100;
                        	result.errorCode := ERR_ACN_ENCODE_PACKET_P_BODY_ANOTHERSIZEARRAY;
                        	i1 := 1; 
                        	if result.Success THEN
                        	    adaasn1rtl.encoding.uper.UPER_Enc_ConstraintWholeNumber(bs, adaasn1rtl.Asn1Int(val.p_body.anotherSizeArray.Length), 1, 7);
                        	        
                        	    while i1<= val.p_body.anotherSizeArray.Length loop
                        	        pragma Loop_Invariant (i1 >=1 and i1<=val.p_body.anotherSizeArray.Length);
                        	        --pragma Loop_Invariant (K >= K'Loop_Entry);
                        	        --pragma Loop_Invariant (K<=K'Loop_Entry + 8*(i1-1));
                        	        adaasn1rtl.encoding.uper.UPER_Enc_ConstraintPosWholeNumber(bs, val.p_body.anotherSizeArray.Data(i1), 1, 8);
                        	        i1 := i1 + 1;
                        	    end loop;
                        	end if;
                    end case;
                    if result.Success then
                        -- Encode Packet_packet_crc32 
                        bitStreamPositions_1.Packet_packet_crc32.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
                        bitStreamPositions_1.Packet_packet_crc32.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
                        adaasn1rtl.encoding.acn.Acn_Enc_NullType_pattern2(bs, BitArray'(1=>0,2=>0,3=>0,4=>0,5=>0,6=>0,7=>0,8=>0,9=>0,10=>0,11=>0,12=>0,13=>0,14=>0,15=>0,16=>0,17=>0,18=>0,19=>0,20=>0,21=>0,22=>0,23=>0,24=>0,25=>0,26=>0,27=>0,28=>0,29=>0,30=>0,31=>0,32=>0));
                        if result.Success then
                            postEncoding.my_encoding_patcher(val, bitStreamPositions_start1, bitStreamPositions_1, bs);
                        end if;
                    end if;
                end if;
            end if;
        end if;
    END IF;
END Packet_ACN_Encode_aux;


PROCEDURE Packet_ACN_Encode(val:in Packet; Stream : out Packet_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
BEGIN
    Stream := Packet_ACN_Stream'(Size_In_Bytes => Packet_REQUIRED_BYTES_FOR_ACN_ENCODING, Current_Bit_Pos  => 0, Buffer => (others => 0));
    Packet_ACN_Encode_aux(val, Stream, result);
END Packet_ACN_Encode;

pragma Warnings (Off, "unused initial value of ""val""");
PROCEDURE Packet_ACN_Decode_aux(val:out Packet; bs : in out adaasn1rtl.encoding.Bitstream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
    bitStreamPositions_1:Packet_extension_function_positions;
    bitStreamPositions_start1:adaasn1rtl.encoding.BitStreamPtr;
    i1:Integer;
    nStringLength:Integer;
    MYMODULE_Packet_p_body_index_tmp:adaasn1rtl.Asn1Int;
BEGIN
    result.Success := True;
    bitStreamPositions_start1.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
    bitStreamPositions_start1.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
    if result.Success then
        -- Decode p_header 
        -- Decode version 
        result.ErrorCode := ERR_ACN_DECODE_PACKET_P_HEADER_VERSION;
        adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, val.p_header.version, 1, 100, 7, result.Success);
        if result.Success then
            -- Decode release 
            result.ErrorCode := ERR_ACN_DECODE_PACKET_P_HEADER_RELEASE;
            adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, val.p_header.release, 1, 100, 7, result.Success);
            if result.Success then
                -- Decode varSizeArray 
                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, nStringLength, 1, 20, 5, result.Success);
                result.errorCode := ERR_ACN_DECODE_PACKET_P_HEADER_VARSIZEARRAY;
                i1 := 1; 
                val.p_header.varSizeArray.Length := nStringLength;
                    
                while i1<= val.p_header.varSizeArray.Length AND result.Success loop
                    pragma Loop_Invariant (i1 >=1 and i1<=val.p_header.varSizeArray.Length);
                    --pragma Loop_Invariant (K.K >= K'Loop_Entry.K);
                    --pragma Loop_Invariant (K.K <= K'Loop_Entry.K + 5*(i1-1));
                    result.ErrorCode := ERR_ACN_DECODE_PACKET_P_HEADER_VARSIZEARRAY_ELM;
                    adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, val.p_header.varSizeArray.Data(i1), 1, 20, 5, result.Success);
                    i1 := i1 + 1;
                end loop;
            end if;
        end if;
        if result.Success then
            -- Decode Packet_body_length_in_bytes 
            bitStreamPositions_1.Packet_body_length_in_bytes.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
            bitStreamPositions_1.Packet_body_length_in_bytes.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
            result.ErrorCode := ERR_ACN_DECODE_PACKET_BODY_LENGTH_IN_BYTES;
            result.Success := TRUE;
            bs.Current_Bit_Pos := bs.Current_Bit_Pos + 16;
            
            if result.Success then
                -- Decode p_body 
                result.ErrorCode := ERR_ACN_DECODE_PACKET_P_BODY;
                adaasn1rtl.encoding.Dec_ConstraintWholeNumber(bs, MYMODULE_Packet_p_body_index_tmp, 0, 2, 2, result.Success);
                if result.Success AND MYMODULE_Packet_p_body_index_tmp >= 0 AND  MYMODULE_Packet_p_body_index_tmp <= 2 THEN
                    case PacketBody_index_range(MYMODULE_Packet_p_body_index_tmp) IS
                        when 0 =>
                          declare
                             aReal_tmp:adaasn1rtl.Asn1Real;
                          begin
                            adaasn1rtl.encoding.uper.UPER_Dec_Real(bs, aReal_tmp, result);
                            if result.Success then
                                val.p_body := PacketBody'(kind => aReal_PRESENT, aReal => aReal_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                        when 1 =>
                          declare
                             anInteger_tmp:PacketBody_anInteger;
                          begin
                            result.ErrorCode := ERR_ACN_DECODE_PACKET_P_BODY_ANINTEGER;
                            adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, anInteger_tmp, 0, 65535, 16, result.Success);
                            if result.Success then
                                val.p_body := PacketBody'(kind => anInteger_PRESENT, anInteger => anInteger_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                        when 2 =>
                          declare
                             anotherSizeArray_tmp:PacketBody_anotherSizeArray;
                          begin
                            adaasn1rtl.encoding.uper.UPER_Dec_ConstraintWholeNumberInt(bs, nStringLength, 1, 100, 7, result.Success);
                            result.errorCode := ERR_ACN_DECODE_PACKET_P_BODY_ANOTHERSIZEARRAY;
                            i1 := 1; 
                            anotherSizeArray_tmp.Length := nStringLength;
                                
                            while i1<= anotherSizeArray_tmp.Length AND result.Success loop
                                pragma Loop_Invariant (i1 >=1 and i1<=anotherSizeArray_tmp.Length);
                                --pragma Loop_Invariant (K.K >= K'Loop_Entry.K);
                                --pragma Loop_Invariant (K.K <= K'Loop_Entry.K + 8*(i1-1));
                                result.ErrorCode := ERR_ACN_DECODE_PACKET_P_BODY_ANOTHERSIZEARRAY_ELM;
                                adaasn1rtl.encoding.uper.UPER_Dec_ConstraintPosWholeNumber(bs, anotherSizeArray_tmp.Data(i1), 1, 200, 8, result.Success);
                                i1 := i1 + 1;
                            end loop;
                            if result.Success then
                                val.p_body := PacketBody'(kind => anotherSizeArray_PRESENT, anotherSizeArray => anotherSizeArray_tmp);
                                pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
                            end if;
                          end;
                    end case;
                end if;
                if result.Success then
                    -- Decode Packet_packet_crc32 
                    bitStreamPositions_1.Packet_packet_crc32.Size_In_Bytes := bs.Size_In_Bytes; --save the size of the bit stream
                    bitStreamPositions_1.Packet_packet_crc32.Current_Bit_Pos := bs.Current_Bit_Pos; --save position of the bit stream
                    result.ErrorCode := ERR_ACN_DECODE_PACKET_PACKET_CRC32;
                    result.Success := TRUE;
                    bs.Current_Bit_Pos := bs.Current_Bit_Pos + 32;
                    
                    if result.Success then
                        result := postEncoding.crc_validator(val, bitStreamPositions_start1, bitStreamPositions_1, bs);
                    end if;
                end if;
            end if;
        end if;
    end if;
END Packet_ACN_Decode_aux;
pragma Warnings (On, "unused initial value of ""val""");

PROCEDURE Packet_ACN_Decode(val: out Packet; Stream : in out Packet_ACN_Stream; result : OUT adaasn1rtl.ASN1_RESULT)
IS
BEGIN
    Stream.Current_Bit_Pos :=0;
    Packet_ACN_Decode_aux(val, Stream, result);
    if result.success then
        result := Packet_IsConstraintValid(val);
    end if;

END Packet_ACN_Decode;


 

END MYMODULE;