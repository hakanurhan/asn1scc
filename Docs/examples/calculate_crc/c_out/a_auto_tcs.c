/*
Code automatically generated by asn1scc tool
*/

#include <string.h>
#include <math.h>
#include <limits.h>
#include <stdio.h>
#include "asn1crt.h"
#include "a_auto_tcs.h"


flag PacketHeader_ACN_enc_dec(const PacketHeader* pVal, int* pErrCode, const char* filename)
{
    static PacketHeader decodedPDU;
    static byte encBuff[PacketHeader_REQUIRED_BYTES_FOR_ACN_ENCODING + 1]; /* +1 for zerosized types */
    BitStream bitStrm;
    flag ret = TRUE;

    BitStream_Init(&bitStrm, encBuff, PacketHeader_REQUIRED_BYTES_FOR_ACN_ENCODING);
    // Encode value
    ret = PacketHeader_ACN_Encode(pVal, &bitStrm, pErrCode, TRUE);
    *pErrCode = ret ? 0 : 1;
    if (ret) {
        BitStream_AttachBuffer(&bitStrm, encBuff, PacketHeader_REQUIRED_BYTES_FOR_ACN_ENCODING);
        // Decode value
        ret = PacketHeader_ACN_Decode(&decodedPDU, &bitStrm, pErrCode);
        *pErrCode = ret ? 0 : 2;
        if (ret) {
            // validate decoded data
            ret = PacketHeader_IsConstraintValid(&decodedPDU, pErrCode);
            *pErrCode = ret ? 0 : 3;
            if (ret) {
                ret = PacketHeader_Equal(pVal, &decodedPDU);
                *pErrCode = ret ? 0 : 4;
                if (ret) {
                    char buf[1024];
                    strcpy(buf, filename);
                    FILE* fp = fopen(strcat(buf,".dat"), "wb");
                    fwrite(bitStrm.buf, 1, bitStrm.count, fp);
                    fclose(fp);
                
                }
            
            }
        
        }
    
    }

    return ret;
}
flag PacketBody_ACN_enc_dec(const PacketBody* pVal, int* pErrCode, const char* filename)
{
    static PacketBody decodedPDU;
    static byte encBuff[PacketBody_REQUIRED_BYTES_FOR_ACN_ENCODING + 1]; /* +1 for zerosized types */
    BitStream bitStrm;
    flag ret = TRUE;

    BitStream_Init(&bitStrm, encBuff, PacketBody_REQUIRED_BYTES_FOR_ACN_ENCODING);
    // Encode value
    ret = PacketBody_ACN_Encode(pVal, &bitStrm, pErrCode, TRUE);
    *pErrCode = ret ? 0 : 1;
    if (ret) {
        BitStream_AttachBuffer(&bitStrm, encBuff, PacketBody_REQUIRED_BYTES_FOR_ACN_ENCODING);
        // Decode value
        ret = PacketBody_ACN_Decode(&decodedPDU, &bitStrm, pErrCode);
        *pErrCode = ret ? 0 : 2;
        if (ret) {
            // validate decoded data
            ret = PacketBody_IsConstraintValid(&decodedPDU, pErrCode);
            *pErrCode = ret ? 0 : 3;
            if (ret) {
                ret = PacketBody_Equal(pVal, &decodedPDU);
                *pErrCode = ret ? 0 : 4;
                if (ret) {
                    char buf[1024];
                    strcpy(buf, filename);
                    FILE* fp = fopen(strcat(buf,".dat"), "wb");
                    fwrite(bitStrm.buf, 1, bitStrm.count, fp);
                    fclose(fp);
                
                }
            
            }
        
        }
    
    }

    return ret;
}
flag Packet_ACN_enc_dec(const Packet* pVal, int* pErrCode, const char* filename)
{
    static Packet decodedPDU;
    static byte encBuff[Packet_REQUIRED_BYTES_FOR_ACN_ENCODING + 1]; /* +1 for zerosized types */
    BitStream bitStrm;
    flag ret = TRUE;

    BitStream_Init(&bitStrm, encBuff, Packet_REQUIRED_BYTES_FOR_ACN_ENCODING);
    // Encode value
    ret = Packet_ACN_Encode(pVal, &bitStrm, pErrCode, TRUE);
    *pErrCode = ret ? 0 : 1;
    if (ret) {
        BitStream_AttachBuffer(&bitStrm, encBuff, Packet_REQUIRED_BYTES_FOR_ACN_ENCODING);
        // Decode value
        ret = Packet_ACN_Decode(&decodedPDU, &bitStrm, pErrCode);
        *pErrCode = ret ? 0 : 2;
        if (ret) {
            // validate decoded data
            ret = Packet_IsConstraintValid(&decodedPDU, pErrCode);
            *pErrCode = ret ? 0 : 3;
            if (ret) {
                ret = Packet_Equal(pVal, &decodedPDU);
                *pErrCode = ret ? 0 : 4;
                if (ret) {
                    char buf[1024];
                    strcpy(buf, filename);
                    FILE* fp = fopen(strcat(buf,".dat"), "wb");
                    fwrite(bitStrm.buf, 1, bitStrm.count, fp);
                    fclose(fp);
                
                }
            
            }
        
        }
    
    }

    return ret;
}
