group a_spec;

rtlModuleName() ::= "adaasn1rtl"


PrintFile(arrsPackages) ::= <<
<arrsPackages; separator="\n\n">
>>

PrintPackageSpec(sPackageName, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrivateChoices, bHasEncodings, bXer) ::= <<
-- Code automatically generated by asn1scc tool
with <rtlModuleName()>;
<if(bHasEncodings)>
with <rtlModuleName()>.encoding;

<endif>
<if(bXer)>
with <rtlModuleName()>.encoding.xer;

<endif>


with system;
use <rtlModuleName()>;
use type <rtlModuleName()>.OctetBuffer;
use type <rtlModuleName()>.BitArray;
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;
<arrsIncludedModules:{inc| WITH <inc>; use <inc>;}; separator="\n">
--# inherit <arrsIncludedModules:{inc| <inc>}; separator=",">;


PACKAGE <sPackageName> with SPARK_Mode
IS


<arrsTypeAssignments:{tas|<tas>}; separator="\n">

<arrsValueAssignments:{vas|<vas>}; separator="\n"> 

private
   --# hide <sPackageName>;

   <arrsPrivateChoices; separator="\n">

END <sPackageName>;
>>



PrintPackageBody(sPackageName, arrsIncludedModules, arrsNegativeReals, arrsBoolPatterns, arrsTypeAssignments, arrsChoiceValueAssignments) ::= <<
-- Code automatically generated by asn1scc tool
<arrsIncludedModules:{inc| WITH <inc>;}; separator="\n">
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;


PACKAGE BODY <sPackageName> IS

<arrsNegativeReals; separator="\n\n">

<arrsBoolPatterns; separator="\n\n">

<arrsTypeAssignments:{tas|<tas>}; separator="\n\n">

<arrsChoiceValueAssignments:{vas|<vas>}; separator="\n\n"> 

END <sPackageName>;
>>



Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>


PrintValueAssignment(sVasName, sTypeDecl, sValue) ::= <<
<sVasName> : CONSTANT <sTypeDecl>:= <sValue>;
>>



ExtraParams(extraPrms) /*nogen*/ ::= "<if(extraPrms)>, <extraPrms; separator=\", \"><endif>"

/* arrsEncDecInOutPrmsNames */



PrintErrorCode(sErrorName, nErrCode, sComment) ::= "<sErrorName>:CONSTANT INTEGER := <nErrCode>; -- <sComment>"


Declare_IntegerNoRTL() ::="Asn1Int"
Declare_PosIntegerNoRTL() ::="Asn1UInt"

Declare_Integer() ::="<rtlModuleName()>.Asn1Int"
Declare_PosInteger() ::="<rtlModuleName()>.Asn1UInt"


Declare_BOOLEAN() ::= "<rtlModuleName()>.Asn1Boolean"
Declare_REAL() ::= "<rtlModuleName()>.Asn1Real"
Declare_NULL() ::= "<rtlModuleName()>.Asn1NullType"

Declare_BOOLEANNoRTL() ::= "Asn1Boolean"
Declare_REALNoRTL() ::= "Asn1Real"

Declare_ObjectIdentifierNoRTL() ::= "Asn1ObjectIdentifier"
Declare_NULLNoRTL() ::= "Asn1NullType"

Declare_Reference1(sName) ::= "<sName>"
Declare_Reference2(sModName,sName) ::= "<sModName>.<sName>"



Define_SubType_int_range(soParentTypePackage, sParentType, noMin, noMax) ::= <<
range <if(noMin)><noMin><else><if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>'First<endif> .. <if(noMax)><noMax><else><if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>'Last<endif>
>>


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs) ::= <<
SUBTYPE <sTypeDefinitionName> is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType><if(soNewRange)> <soNewRange><endif>;
<soExtraDefs>
>>

/******************************************************************************************************************************/
/***********************************       NEW TYPE DEFINITIONS    ************************************************************/
/******************************************************************************************************************************/

define_subtype(thisType, parentType, soParentTypePackage) ::= /*nogen*/<<
SUBTYPE <thisType> is <if(soParentTypePackage)><soParentTypePackage>.<endif><parentType>;
>>

/***********************************       ENUMERATED    ************************************************************/


Define_new_enumerated_item(sName, nValue) ::= "<sName> => <nValue>"

Define_new_enumerated_item_macro(td/*:FE_EnumeratedTypeDefinition*/, sAsn1Name, sCName) ::= ""

Define_new_enumerated(td/*:FE_EnumeratedTypeDefinition*/, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax, arrsResolvingMacros) ::= <<
subtype <td.index_range> is integer range 0..<nIndexMax>;
type <td.typeName> is (<arrsEnumNames; separator=", ">) with Convention => C;
for <td.typeName> use
    (<arrsEnumNamesAndValues; separator=", ">);
>>

Define_subType_enumerated(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, soParentTypePackage) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.index_range, parentType=prTd.index_range, soParentTypePackage=soParentTypePackage)>
>>



/***********************************       STRING    ************************************************************/

Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
SUBTYPE <td.encoding_range> is integer range <nMin>..<nMax>;
SUBTYPE <td.index> is integer range 1..<nCMax>;
SUBTYPE <td.typeName> IS String(<td.index>);
<if(arrnAlphaChars)>
SUBTYPE <td.alpha_index> is integer range 1..<arrnAlphaChars.Length>;
SUBTYPE <td.alpha> IS String(<td.alpha_index>);
<td.alpha_set> : constant <td.alpha> := <td.alpha>'(<arrnAlphaChars:{c|<i>=>Character'Val(<c>)}; wrap, anchor,  separator=", ">);

<endif>
>>


Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<
SUBTYPE <td.typeName> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.typeName>
SUBTYPE <td.encoding_range> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.encoding_range>;
SUBTYPE <td.index> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.index>;
<if(arrnAlphaChars)>
SUBTYPE <td.alpha_index> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.alpha_index>;
SUBTYPE <td.alpha> <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.alpha>;
<td.alpha_set> : constant := <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.alpha_set>;

<endif>
>>


/***********************************       OCTET STRING    ************************************************************/
Define_new_octet_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize) ::= <<
SUBTYPE <td.index> is integer range 1..<nMax>;
SUBTYPE <td.array> IS <rtlModuleName()>.OctetBuffer(<td.index>);
<if(!bFixedSize)>SUBTYPE <td.length_index> is integer range <nMin>..<nMax>;<endif>
type <td.typeName> is  record
<if(!bFixedSize)>    Length : <td.length_index>;<endif>
    Data  : <td.array>;
end record;
>>

Define_subType_octet_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.index, parentType=prTd.index, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.array, parentType=prTd.array, soParentTypePackage=soParentTypePackage)>
<if(!bFixedSize)>
<define_subtype(thisType=td.length_index, parentType=prTd.length_index, soParentTypePackage=soParentTypePackage)>

<endif>
>>


/***********************************       BIT STRING    ************************************************************/
Define_new_bit_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, nMaxOctets) ::= <<
SUBTYPE <td.index> is integer range 1..<nMax>;
SUBTYPE <td.array> IS <rtlModuleName()>.BitArray(<td.index>);
<if(!bFixedSize)>SUBTYPE <td.length_index> is integer range <nMin>..<nMax>;<endif>
type <td.typeName> is  record
<if(!bFixedSize)>    Length : <td.length_index>;<endif>
    Data  : <td.array>;
end record;
>>

Define_subType_bit_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.index, parentType=prTd.index, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.array, parentType=prTd.array, soParentTypePackage=soParentTypePackage)>
<if(!bFixedSize)>
<define_subtype(thisType=td.length_index, parentType=prTd.length_index, soParentTypePackage=soParentTypePackage)>

<endif>
>>


/***********************************       SEQUENCE OF    ************************************************************/

Define_new_sequence_of(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, sChildType, soChildDefintion) ::= <<
-- <td.typeName> --------------------------------------------

<soChildDefintion>

subtype <td.index> is integer range 1..<nMax>;
type <td.array> is array (<td.index>) of <sChildType>;
<if(!bFixedSize)>subtype <td.length_index> is integer range <nMin>..<nMax>;<endif>
type <td.typeName> is  record
<if(!bFixedSize)>    Length : <td.length_index>;<endif>
    Data  : <td.array>;
end record;
>>

Define_subType_sequence_of(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.index, parentType=prTd.index, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.array, parentType=prTd.array, soParentTypePackage=soParentTypePackage)>
<if(!bFixedSize)>
<define_subtype(thisType=td.length_index, parentType=prTd.length_index, soParentTypePackage=soParentTypePackage)>

<endif>
>>

/***********************************       SEQUENCE    ************************************************************/

Define_new_sequence_child_bit(sName) ::= "<sName>:<rtlModuleName()>.bit;"

Define_new_sequence_child(sName, sType) ::= "<sName> : <sType>;"
Define_new_sequence_save_pos_child(td/*:FE_SequenceTypeDefinition*/, sName, nMaxBytesInACN) ::= "<sName> : <rtlModuleName()>.encoding.BitstreamPtr;"

Define_new_sequence(td/*:FE_SequenceTypeDefinition*/, arrsChildren, arrsOptionalChildren, arrsChildldrenDefintions, arrsNullFieldsSavePos) ::= <<
-- <td.typeName> --------------------------------------------
<arrsChildldrenDefintions; separator= "\n">

<if(arrsChildren)>
<if (arrsOptionalChildren)>
type <td.exist> is record
    <arrsOptionalChildren; separator="\n">
end record with Pack;

for <td.exist>'Size use ((<length(arrsOptionalChildren)> - 1) / System.Word_Size + 1) * System.Word_Size;

<endif>
<if (arrsNullFieldsSavePos)>
type <td.extention_function_potisions> is record
    <arrsNullFieldsSavePos; separator="\n">
end record;

<endif>
type <td.typeName> is record 
    <arrsChildren; separator="\n">
    <if (arrsOptionalChildren)>
    
    Exist : <td.exist>;

    <endif>
end record;

<else>
type <td.typeName> is record 
    null;
end record;

<endif>
>>

Define_subType_sequence(td/*:FE_SequenceTypeDefinition*/, prTd/*:FE_SequenceTypeDefinition*/, soParentTypePackage, arrsOptionalChildren) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<if(arrsOptionalChildren)>
<define_subtype(thisType=td.exist, parentType=prTd.exist, soParentTypePackage=soParentTypePackage)>

<endif>
<if (arrsNullFieldsSavePos)>
<define_subtype(thisType=td.extention_function_potisions, parentType=prTd.extention_function_potisions, soParentTypePackage=soParentTypePackage)>

<endif>

>>


/***********************************       CHOICE    ************************************************************/

Define_new_choice_child(sName, sType, sPresent) ::=<<
when <sPresent> =>
        <sName>: <sType>;
>>

Define_new_choice(td/*:FE_ChoiceTypeDefinition*/, sChoiceIDForNone, sFirstChildNamePresent, arrsChildren, arrsPresent, nIndexMax, arrsChildldrenDefintions) ::= <<
-- <td.typeName> --------------------------------------------
<arrsChildldrenDefintions; separator= "\n">

subtype <td.index_range> is integer range 0..<nIndexMax>;

type <td.selection> is (<arrsPresent; separator=", ">);
for <td.selection> use
    (<arrsPresent:{c|<c> => <i>}; separator=", ">);
for <td.selection>'Size use 32;

type <td.typeName>(kind : <td.selection>:= <sFirstChildNamePresent>) is 
record
    case kind is
    <arrsChildren; separator="\n">
    end case;
end record;

for <td.typeName> use 
record
    kind at 0 range 0..31;
end record;
>>

Define_subType_choice(td/*:FE_ChoiceTypeDefinition*/, prTd/*:FE_ChoiceTypeDefinition*/, soParentTypePackage) ::= <<
<define_subtype(thisType=td.typeName, parentType=prTd.typeName, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.index_range, parentType=prTd.index_range, soParentTypePackage=soParentTypePackage)>
<define_subtype(thisType=td.selection, parentType=prTd.selection, soParentTypePackage=soParentTypePackage)>
>>

