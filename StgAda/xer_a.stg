group a_xer;

rtlModuleName() ::= "adaasn1rtl"



EmitTypeAssignment_def_err_code(sErrCode, nErrValue) ::= <<
<sErrCode>:CONSTANT INTEGER := <nErrValue>; 
>>

EmitTypeAssignment_def_encode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInXER, soSparkAnnotations) ::= <<
<arrsErrcodes; separator="\n">
<sTypeDefName>_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER := <nMaxBytesInXER>;

SUBTYPE <sTypeDefName>_XER_byte_array_range is Natural range 1..<if(bEmptyEncodingSpace)>1<else><sTypeDefName>_REQUIRED_BYTES_FOR_XER_ENCODING<endif>;
SUBTYPE <sTypeDefName>_XER_byte_array is <rtlModuleName()>.OctetBuffer(<sTypeDefName>_XER_byte_array_range);

subtype <sTypeDefName>_XER_Stream is adaasn1rtl.encoding.xer.CharStream(<if(bEmptyEncodingSpace)>1<else><sTypeDefName>_REQUIRED_BYTES_FOR_XER_ENCODING<endif>);

procedure <sFuncName>(val:in <sTypeDefName>; Stream : OUT <sTypeDefName>_XER_Stream; ret : OUT <rtlModuleName()>.ASN1_RESULT);
procedure <sFuncName>_aux(<sVarName>:in <sTypeDefName>; xmlTag : in <rtlModuleName()>.encoding.xer.XString; bs : in out <rtlModuleName()>.encoding.xer.CharStream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
<soSparkAnnotations>;
>>

EmitTypeAssignment_encode(sTasName, sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp) ::= <<
procedure <sFuncName>_aux(<sVarName>:in <sTypeDefName>; xmlTag : in <rtlModuleName()>.encoding.xer.XString; bs : in out <rtlModuleName()>.encoding.xer.CharStream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
is
    <arrsLocalVariables; separator="\n">
begin
    <if(soIValidFuncName)>
    ret := <soIValidFuncName>(<sVarName>);
    if ret.success THEN
        <sContent>
    end if;
    <else>
    ret := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
    <sContent>
    <endif>
end <sFuncName>_aux;

procedure <sFuncName>(<sVarName>:in <sTypeDefName>; Stream : OUT <sTypeDefName>_XER_Stream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
is
begin
    Stream := <sTypeDefName>_XER_Stream'(N => <if(bEmptyEncodingSpace)>1<else><sTypeDefName>_REQUIRED_BYTES_FOR_XER_ENCODING<endif>,
										 CurrentByte => 1,
										 Data      => (others => Character'Val (0)),
                                         EncodeWhiteSpace => False);
    <sFuncName>_aux(<sVarName>, "<sTasName>", Stream,  ret);
end <sFuncName>;

>>


EmitTypeAssignment_def_decode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInXER, soSparkAnnotations) ::= <<
<arrsErrcodes; separator="\n">
procedure <sFuncName>(<sVarName>: out <sTypeDefName>; Stream : in out <sTypeDefName>_XER_Stream; ret : OUT <rtlModuleName()>.ASN1_RESULT);
procedure <sFuncName>_aux(<sVarName>: out <sTypeDefName>; xmlTag : in <rtlModuleName()>.encoding.xer.XString; bs : in out <rtlModuleName()>.encoding.xer.CharStream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
<soSparkAnnotations>;
>>



EmitTypeAssignment_decode(sTasName, sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp) ::= <<
pragma Warnings (Off, "unused initial value of ""val""");
procedure <sFuncName>_aux(<sVarName>: out <sTypeDefName>; xmlTag : in <rtlModuleName()>.encoding.xer.XString; bs : in out <rtlModuleName()>.encoding.xer.CharStream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
IS
    <arrsLocalVariables; separator="\n">
begin
    <sContent>
end <sFuncName>_aux;
pragma Warnings (On, "unused initial value of ""val""");

procedure <sFuncName>(<sVarName>: out <sTypeDefName>; Stream : in out <sTypeDefName>_XER_Stream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
is
begin
    <sFuncName>_aux(<sVarName>, "<sTasName>", Stream, ret);
end <sFuncName>;

>>



Integer_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_EncodeInteger(bs, <sTag>, <p>, ret, <nLevel>);
ret.ErrorCode := <sErrCode>;
>>

Integer_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_DecodeInteger(bs, <sTag>, <p>, ret);
<if(soCheckExp)><soCheckExp><endif>
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>


IntegerPos_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_EncodePosInteger(bs, <sTag>, <p>, ret, <nLevel>);
ret.ErrorCode := <sErrCode>;
>>

IntegerPos_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_DecodePosInteger(bs, <sTag>, <p>, ret);
<if(soCheckExp)><soCheckExp><endif>
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>


Boolean_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_EncodeBoolean(bs, <sTag>, <p>, ret, <nLevel>);
ret.ErrorCode := <sErrCode>;
>>


Boolean_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_DecodeBoolean(bs, <sTag>, <p>, ret);
<if(soCheckExp)><soCheckExp><endif>
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>

Real_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_EncodeReal(bs, <sTag>, <p>, ret, <nLevel>);
ret.ErrorCode := <sErrCode>;
>>

Real_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_DecodeReal(bs, <sTag>, <p>, ret);
<if(soCheckExp)><soCheckExp><endif>
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>

ObjectIdentifier_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_EncodeObjectIdentifier(bs, <sTag>, <p>, ret, <nLevel>);
>>

ObjectIdentifier_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_DecodeObjectIdentifier(bs, <sTag>, <p>, ret);
<if(soCheckExp)><soCheckExp><endif>
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>




String_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_EncodeString(bs, <sTag>, <p>, ret, <nLevel>);
ret.ErrorCode := <sErrCode>;
>>

String_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_DecodeString(bs, <sTag>, <p>, ret);
<if(soCheckExp)><soCheckExp><endif>
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>


Enumerated_item_encode(p, sTag, nLevel, sItemID, sXerValue, sErrCode, bFirst) ::= <<
when <sItemID>    => 
	adaasn1rtl.encoding.xer.Xer_EncodeEnumerated(bs, <sTag>, "<sXerValue>", ret, <nLevel>);
    ret.ErrorCode := <sErrCode>;
>>

Enumerated_encode(p, sTag, nLevel, arrsItems, soCheckExp, sErrCode) ::= <<
case <p> is 
    <arrsItems; separator="\n">
end case;
>>


Enumerated_item_decode(p, sTag, nLevel, sItemID, sXerValue, sErrCode, bFirst) ::= <<
<if(!bFirst)>els<endif>if enmLabel = <sXerValue> then
    <p> := <sItemID>;
>>

Enumerated_decode(p, sTag, nLevel, arrsItems, soCheckExp, sErrCode) ::= <<
declare
	enmLabel : char [200];
begin
	ret = adaasn1rtl.encoding.xer.Xer_DecodeEnumerated(bs, <sTag>, enmLabel, ret);
    if ret.ErrorCode then
        <arrsItems; separator="\n">
	    else 
		    ret.ErrorCode := <sErrCode>;
	    endif;
    else
	    ret.ErrorCode := <sErrCode>;
    endif;

end;
>>



OctetString_encode(p, sAcc, sTag, nLevel, nSizeMax, bIsFixedSize, soCheckExp, sErrCode) ::= <<
ret = adaasn1rtl.encoding.xer.Xer_EncodeOctetString(bs, <sTag>, <p><sAcc>arr, <if(!bIsFixedSize)><p><sAcc>nCount<else><nSizeMax><endif>, ret, <nLevel>);
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>

OctetString_decode(p, sAcc, sTag, nLevel, nSizeMax, bIsFixedSize, soCheckExp, sErrCode) ::= <<
ret = adaasn1rtl.encoding.xer.Xer_DecodeOctetString(bs, <sTag>, <p><sAcc>arr, <if(!bIsFixedSize)><p><sAcc>nCount<else>NULL<endif>, ret);
<if(soCheckExp)><soCheckExp><endif>
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>


BitString_encode(p, sAcc, sTag, nLevel, nSizeMax, bIsFixedSize, soCheckExp, sErrCode) ::= <<
ret = adaasn1rtl.encoding.xer.Xer_EncodeBitString(bs, <sTag>, <p><sAcc>arr, <if(!bIsFixedSize)><p><sAcc>nCount<else><nSizeMax><endif>, ret, <nLevel>);
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>

BitString_decode(p, sAcc, sTag, nLevel, nSizeMax, bIsFixedSize, soCheckExp, sErrCode) ::= <<
ret = adaasn1rtl.encoding.xer.Xer_DecodeBitString(bs, <sTag>, <p><sAcc>arr, <if(!bIsFixedSize)>&<p><sAcc>nCount<else>NULL<endif>, pErrCode);
<if(soCheckExp)><soCheckExp><endif>
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>


SequenceOf_encode(p, sAcc, sTag, nLevel, sI, nSizeMax, sChildBody, bFixedSize, soCheckExp, sErrCode) ::= <<
/* SEQUENCE OF Encode*/
ret := adaasn1rtl.encoding.xer.Xer_EncodeComplexElementStart(bs, <sTag>, ret, <nLevel>);
if (ret.ErrorCode) then
    for(<sI>=0;((<sI> \< <if(!bFixedSize)><p><sAcc>nCount<else><nSizeMax><endif>) && ret);<sI>++) 
    {
	    <sChildBody>
    }
    if (ret) {
        ret = adaasn1rtl.encoding.xer.Xer_EncodeComplexElementEnd(bs, <sTag>, ret, <nLevel>);
		ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
    }
endif;
>>


SequenceOf_decode(p, sAcc, sTag, nLevel, sI, nSizeMax, sChildBody, bFixedSize, soCheckExp, sErrCode) ::= <<
/* SEQUENCE OF Decode*/
ret = Xer_DecodeComplexElementStart(bs, <sTag>, NULL, pErrCode);
if (ret) {
    <if(!bFixedSize)><p><sAcc>nCount = 0;<endif>
    <sI> = 0;
    while(ret && !Xer_NextEndElementIs(bs, <sTag>))
    {
	    <sChildBody>
	    <sI>++;
	    <if(!bFixedSize)><p><sAcc>nCount++;<endif>
    }
    if (ret) {
        ret = Xer_DecodeComplexElementEnd(bs, <sTag>, pErrCode);
    }
}
<if(bFixedSize)>
*pErrCode = (ret && <sI> == <nSizeMax>) ? 0 : <sErrCode>;

<else>
<if(soCheckExp)><soCheckExp><endif>
*pErrCode = ret  ? 0 : <sErrCode>;

<endif>
>>
