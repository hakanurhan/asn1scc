group a_xer;

rtlModuleName() ::= "adaasn1rtl"



EmitTypeAssignment_def_err_code(sErrCode, nErrValue) ::= <<
<sErrCode>:CONSTANT INTEGER := <nErrValue>; 
>>

EmitTypeAssignment_def_encode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInXER, soSparkAnnotations) ::= <<
<arrsErrcodes; separator="\n">
<sTypeDefName>_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER := <nMaxBytesInXER>;

SUBTYPE <sTypeDefName>_XER_byte_array_range is Natural range 1..<if(bEmptyEncodingSpace)>1<else><sTypeDefName>_REQUIRED_BYTES_FOR_XER_ENCODING<endif>;
SUBTYPE <sTypeDefName>_XER_byte_array is <rtlModuleName()>.OctetBuffer(<sTypeDefName>_XER_byte_array_range);

--TYPE <sTypeDefName>_XER_Stream IS RECORD
--    K	: Natural;
--    DataLen	: Natural;
--    Data : <sTypeDefName>_XER_byte_array;
--end RECORD;

subtype <sTypeDefName>_XER_Stream is adaasn1rtl.encoding.xer.CharStream(<if(bEmptyEncodingSpace)>1<else><sTypeDefName>_REQUIRED_BYTES_FOR_XER_ENCODING<endif>);

procedure <sFuncName>(val:in <sTypeDefName>; Stream : OUT <sTypeDefName>_XER_Stream; ret : OUT <rtlModuleName()>.ASN1_RESULT);
procedure <sFuncName>_aux(<sVarName>:in <sTypeDefName>; xmlTag : in <rtlModuleName()>.encoding.xer.XString; bs : in out <rtlModuleName()>.encoding.xer.CharStream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
<soSparkAnnotations>;
>>

EmitTypeAssignment_encode(sTasName, sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp) ::= <<
procedure <sFuncName>_aux(<sVarName>:in <sTypeDefName>; xmlTag : in <rtlModuleName()>.encoding.xer.XString; bs : in out <rtlModuleName()>.encoding.xer.CharStream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
is
    <arrsLocalVariables; separator="\n">
begin
    <if(soIValidFuncName)>
    ret := <soIValidFuncName>(<sVarName>);
    if ret.success THEN
        <sContent>
    end if;
    <else>
    ret := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
    <sContent>
    <endif>
end <sFuncName>_aux;

procedure <sFuncName>(<sVarName>:in <sTypeDefName>; Stream : OUT <sTypeDefName>_XER_Stream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
is
begin
    Stream := <sTypeDefName>_XER_Stream'(N => <if(bEmptyEncodingSpace)>1<else><sTypeDefName>_REQUIRED_BYTES_FOR_XER_ENCODING<endif>,
										 CurrentByte => 1,
										 Data      => (others => Character'Val (0)),
                                         EncodeWhiteSpace => False);
    <sFuncName>_aux(<sVarName>, "<sTasName>", Stream,  ret);
end <sFuncName>;

>>


EmitTypeAssignment_def_decode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInXER, soSparkAnnotations) ::= <<
<arrsErrcodes; separator="\n">
procedure <sFuncName>(<sVarName>: out <sTypeDefName>; Stream : in out <sTypeDefName>_XER_Stream; ret : OUT <rtlModuleName()>.ASN1_RESULT);
procedure <sFuncName>_aux(<sVarName>: out <sTypeDefName>; xmlTag : in <rtlModuleName()>.encoding.xer.XString; bs : in out <rtlModuleName()>.encoding.xer.CharStream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
<soSparkAnnotations>;
>>



EmitTypeAssignment_decode(sTasName, sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp) ::= <<
pragma Warnings (Off, "unused initial value of ""val""");
procedure <sFuncName>_aux(<sVarName>: out <sTypeDefName>; xmlTag : in <rtlModuleName()>.encoding.xer.XString; bs : in out <rtlModuleName()>.encoding.xer.CharStream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
IS
    <arrsLocalVariables; separator="\n">
begin
    <sContent>
end <sFuncName>_aux;
pragma Warnings (On, "unused initial value of ""val""");

procedure <sFuncName>(<sVarName>: out <sTypeDefName>; Stream : in out <sTypeDefName>_XER_Stream; ret : OUT <rtlModuleName()>.ASN1_RESULT)
is
begin
    <sFuncName>_aux(<sVarName>, "<sTasName>", Stream, ret);
end <sFuncName>;

>>



Integer_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_EncodeInteger(bs, <sTag>, <p>, ret, <nLevel>);
ret.ErrorCode := <sErrCode>;
>>

Integer_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_DecodeInteger(bs, <sTag>, <p>, ret);
<if(soCheckExp)><soCheckExp><endif>
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>


IntegerPos_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_EncodePosInteger(bs, <sTag>, <p>, ret, <nLevel>);
ret.ErrorCode := <sErrCode>;
>>

IntegerPos_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
adaasn1rtl.encoding.xer.Xer_DecodePosInteger(bs, <sTag>, <p>, ret);
<if(soCheckExp)><soCheckExp><endif>
ret.ErrorCode := (if ret.Success then 0 else <sErrCode>);
>>


Boolean_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
Xer_EncodeBoolean(Strm, "<sTag>", <p>, ret, <nLevel>);
ret.ErrorCode := <sErrCode>;
>>


Boolean_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
Xer_DecodeBoolean(Strm, "<sTag>", <p>, ret);
ret := <rtlModuleName()>.ASN1_RESULT'(Success => ret.Success <if(soCheckExp)>and then (<soCheckExp>)<endif>, ErrorCode => <sErrCode>);
>>

Real_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
Xer_EncodeReal(Strm, "<sTag>", <p>, ret, <nLevel>);
ret.ErrorCode := <sErrCode>;
>>

Real_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
Xer_DecodeReal(Strm, "<sTag>", <p>, ret);
ret := <rtlModuleName()>.ASN1_RESULT'(Success => ret.Success <if(soCheckExp)>and then (<soCheckExp>)<endif>, ErrorCode => <sErrCode>);
>>

ObjectIdentifier_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
Xer_EncodeObjectIdentifier(Strm, "<sTag>", <p>, ret, <nLevel>);
>>

ObjectIdentifier_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
Xer_DecodeObjectIdentifier(Strm, "<sTag>", <p>, ret);
ret := <rtlModuleName()>.ASN1_RESULT'(Success => ret.Success <if(soCheckExp)>and then (<soCheckExp>)<endif>, ErrorCode => <sErrCode>);
>>




String_encode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
Xer_EncodeString(Strm, "<sTag>", <p>, ret, <nLevel>);
ret.ErrorCode := <sErrCode>;
>>

String_decode(p, sTag, nLevel, soCheckExp, sErrCode) ::= <<
Xer_DecodeString(Strm, "<sTag>", <p>, ret);
ret := <rtlModuleName()>.ASN1_RESULT'(Success => ret.Success <if(soCheckExp)>and then (<soCheckExp>)<endif>, ErrorCode => <sErrCode>);
>>


Enumerated_item_encode(p, sTag, nLevel, sItemID, sXerValue, sErrCode, bFirst) ::= <<
when <sItemID>    => 
	Xer_EncodeEnumerated(Strm, "<sTag>", "<sXerValue>", pErrCode, <nLevel>);
    ret.ErrorCode := <sErrCode>;
>>

Enumerated_encode(p, sTag, nLevel, arrsItems, soCheckExp, sErrCode) ::= <<
case <p> is 
    <arrsItems; separator="\n">
end case;
>>


Enumerated_item_decode(p, sTag, nLevel, sItemID, sXerValue, sErrCode, bFirst) ::= <<
<if(!bFirst)>else <endif>if(strcmp(enmLabel,"<sXerValue>") == 0)
    <p> = <sItemID>;
>>

Enumerated_decode(p, sTag, nLevel, arrsItems, soCheckExp, sErrCode) ::= <<
declare
	enmLabel : char [200];
begin
	ret = Xer_DecodeEnumerated(Strm, <sTag>, enmLabel, pErrCode);
    if (ret) {
        <arrsItems; separator="\n">
	    else {
		    *pErrCode = <sErrCode>;
	    }
    } else {
        *pErrCode = <sErrCode>;
    }

end;
>>



OctetString_encode(p, sAcc, sTag, nLevel, nSizeMax, bIsFixedSize, soCheckExp, sErrCode) ::= <<
ret = Xer_EncodeOctetString(pByteStrm, <sTag>, <p><sAcc>arr, <if(!bIsFixedSize)><p><sAcc>nCount<else><nSizeMax><endif>, pErrCode, <nLevel>);
*pErrCode = ret ? 0 : <sErrCode>;
>>

OctetString_decode(p, sAcc, sTag, nLevel, nSizeMax, bIsFixedSize, soCheckExp, sErrCode) ::= <<
ret = Xer_DecodeOctetString(pByteStrm, <sTag>, <p><sAcc>arr, <if(!bIsFixedSize)>&<p><sAcc>nCount<else>NULL<endif>, pErrCode);
*pErrCode = (ret <if(soCheckExp)> && (<soCheckExp>)<endif>) ? 0 : <sErrCode>;
>>


BitString_encode(p, sAcc, sTag, nLevel, nSizeMax, bIsFixedSize, soCheckExp, sErrCode) ::= <<
ret = Xer_EncodeBitString(pByteStrm, <sTag>, <p><sAcc>arr, <if(!bIsFixedSize)><p><sAcc>nCount<else><nSizeMax><endif>, pErrCode, <nLevel>);
*pErrCode = ret ? 0 : <sErrCode>;
>>

BitString_decode(p, sAcc, sTag, nLevel, nSizeMax, bIsFixedSize, soCheckExp, sErrCode) ::= <<
ret = Xer_DecodeBitString(pByteStrm, <sTag>, <p><sAcc>arr, <if(!bIsFixedSize)>&<p><sAcc>nCount<else>NULL<endif>, pErrCode);
*pErrCode = (ret <if(soCheckExp)> && (<soCheckExp>)<endif>) ? 0 : <sErrCode>;
>>

