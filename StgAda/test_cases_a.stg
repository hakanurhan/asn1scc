/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group spark_automatic_test_cases;

rtlModuleName() ::= "adaasn1rtl"


PrintCodecsFile_spec(sModName, arrsIncludedModules, arrsTestFunctions) ::= <<
-- Code automatically generated by asn1scc tool
with adaasn1rtl;
with <sModName>;

<arrsIncludedModules:{inc| WITH <inc>;}; separator="\n">
<if(arrsIncludedModules)>
--# inherit <arrsIncludedModules; separator=",">;

<endif>
PACKAGE <sModName>_auto_tcs
IS

<arrsTestFunctions; separator="\n\n">

end <sModName>_auto_tcs;
>>
                
PrintCodec_spec(sFuncName, sModName, sTasName, sStar, sVal) ::= <<
FUNCTION <sFuncName>(<sVal>:<sModName>.<sTasName>; Filename : in String) RETURN <rtlModuleName()>.TEST_CASE_RESULT;
>>


PrintCodecsFile_body(sModName, arrsIncludedModules, arrsTasNames, arrsTestFunctions) ::= <<
-- Code automatically generated by asn1scc tool
with Interfaces;
with adaasn1rtl;
with adaasn1rtl.encoding.test_cases_aux;
with <sModName>;
use type Interfaces.Unsigned_8;
with <rtlModuleName()>;
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;
<arrsIncludedModules:{inc| WITH <inc>; USE <inc>;}; separator="\n">
<arrsTasNames: {tasName|use type <tasName>;}; separator="\n">
PACKAGE BODY <sModName>_auto_tcs 
IS 

<arrsTestFunctions; separator="\n\n">

end <sModName>_auto_tcs;
>>



Codec_UpdateDecInParam_no_result(sModName, sTasName, sParamName) ::= <<
<sModName>.<sTasName>_ACN_Encode_update_<sParamName>(val,  dec_<sParamName>);
>>

Codec_UpdateDecInParam_with_result(sModName, sTasName, sParamName) ::= <<
<sModName>.<sTasName>_ACN_Encode_update_<sParamName>(val,  dec_<sParamName>, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_VALIDATE, Success => result.Success, ErrorCode => result.ErrorCode);
>>


Codec_validate_input(sModName, sFuncName, sAmber) ::= <<
-- Check value against ASN.1 constraints
result := <sModName>.<sFuncName>(val);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_VALIDATE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_Encode(sModName, sFuncName, sVal) ::= <<
-- Encode value
<sModName>.<sFuncName>(<sVal>, stream, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_ENCODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_Decode(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
-- Decode value
--at this point stream contains the <sEnc> data
stream.Current_Bit_Pos :=0;
<sModName>.<sFuncName>(decodedPDU, stream, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_Decode_XER(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
-- Decode value
--at this point stream contains the <sEnc> data
<sModName>.<sFuncName>(decodedPDU, stream, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>



Codec_validate_output(sModName, sFuncName, sAmber) ::= <<
-- validate decoded data
result := <sModName>.<sFuncName>(decodedPDU);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_VALIDATE_DECODED, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_compare_input_with_output(sModName, sFuncName, sVal, sAmber) ::= <<
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_EQUAL, Success => <sModName>.<sFuncName>(<sVal>, decodedPDU), ErrorCode => result.ErrorCode);
>>

Codec_write_bitstreamToFile() ::= <<
adaasn1rtl.encoding.test_cases_aux.Write_BitStream_To_File(stream, Filename & ".dat");
>>

JoinItems(sPart, soNestedPart) ::= <<
<sPart>
<if(soNestedPart)>
if result.Success THEN
    <soNestedPart>
end if;

<endif>
>>


Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
enc_<sPrmName> : CONSTANT <sType> := <sPrmValue>;
dec_<sPrmName> : <sType>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "dec_<sPrmName> : <sType>;"

        



PrintCodec_body(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
FUNCTION <sFuncName>(<sVal>:<sModName>.<sTasName>; Filename : in String) RETURN <rtlModuleName()>.TEST_CASE_RESULT
IS
    decodedPDU  : <sModName>.<sTasName>;
    stream      : adaasn1rtl.encoding.Bitstream := adaasn1rtl.encoding.BitStream_init((if <sModName>.<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING = 0 then 1 else <sModName>.<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING));
    result      : <rtlModuleName()>.ASN1_RESULT;
    ret         : <rtlModuleName()>.TEST_CASE_RESULT;
BEGIN
    <sNestedStatements>
    RETURN ret;
end <sFuncName>;
>>

PrintCodec_body_XER(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
FUNCTION <sFuncName>(<sVal>:<sModName>.<sTasName>) RETURN <rtlModuleName()>.TEST_CASE_RESULT
IS
    decodedPDU  : <sModName>.<sTasName>;
    stream      : <sModName>.<sTasName>_<sEnc>Stream;
    result      : <rtlModuleName()>.ASN1_RESULT;
    ret         : <rtlModuleName()>.TEST_CASE_RESULT;
BEGIN
    <sNestedStatements>
    RETURN ret;
end <sFuncName>;
>>


/*
//////////////////////////// CALL TEST CASES ////////////////////////////////////////////////////////////////////
*/



/* 
Code calling a test case
*/                   
PrintMain_call_codec(sModName, sTasName, sAmber, sEnc, sValue, sValueAsAsn1, sVasName, bStatic, sGenerateDatFile, soInitFunction, sInitAmber) ::= <<
result := <sTasName>_<sEnc>enc_dec(<sValue>);
if NOT result.Success THEN
    case result.Step IS
        when <rtlModuleName()>.TC_VALIDATE =>
            Put_Line ("Test case '<sVasName>' failed in validation"); 
        when <rtlModuleName()>.TC_ENCODE =>
            Put_Line ("Test case '<sVasName>' failed in encoding");
        when <rtlModuleName()>.TC_DECODE =>
            Put_Line ("Test case '<sVasName>' failed in decoding");
        when <rtlModuleName()>.TC_VALIDATE_DECODED =>
            Put_Line ("Test case '<sVasName>' failed in the validation of the decoded message");
        when <rtlModuleName()>.TC_EQUAL =>
            Put_Line ("Test case '<sVasName>' failed. Encoded and decoded messages are different");
    end case;
    Put_Line ("Test Value was <sValueAsAsn1>");
    Put_Line ("========================================");
    totalErrors := totalErrors + 1;
end if;
<sGenerateDatFile>

>>


PrintMain_call_codec2(sModName, sTasName, sAmber, sEnc, sInitializeTcData, sValueAsAsn1, sVasName, bStatic, sGenerateDatFile, soInitFunction, sInitAmber) ::= <<
declare
    tc_data : <sTasName>;
begin
    <if(soInitFunction)>
    -- dummy statement used for calling init functions
    tc_data := <soInitFunction>;
    <endif>
    --the actual initialization with the test case data is made here.
    <sInitializeTcData>
    result := <sTasName>_<sEnc>enc_dec(tc_data);
    if NOT result.Success THEN
        case result.Step IS
            when <rtlModuleName()>.TC_VALIDATE =>
                Put_Line ("Test case '<sVasName>' failed in validation"); 
            when <rtlModuleName()>.TC_ENCODE =>
                Put_Line ("Test case '<sVasName>' failed in encoding");
            when <rtlModuleName()>.TC_DECODE =>
                Put_Line ("Test case '<sVasName>' failed in decoding");
            when <rtlModuleName()>.TC_VALIDATE_DECODED =>
                Put_Line ("Test case '<sVasName>' failed in the validation of the decoded message");
            when <rtlModuleName()>.TC_EQUAL =>
                Put_Line ("Test case '<sVasName>' failed. Encoded and decoded messages are different");
        end case;
        Put_Line ("Test Value was <sValueAsAsn1>");
        Put_Line ("========================================");
        totalErrors := totalErrors + 1;
    end if;
    <sGenerateDatFile>
end;
>>



PrintMain_call_codec_generate_dat_file(sModName, sTasName, sAmber, sEnc, sStreamName) ::= <<
if result.Success THEN
    DECLARE
    	stream   : <sModName>.<sTasName>_uPER_Stream;
        ret      : <rtlModuleName()>.ASN1_RESULT;
    BEGIN
        <sModName>.<sTasName>_uPER_Encode(<sValue>, stream, ret);
	    WRITE_STR_TO_FILE(Strm => stream.Data,DataLen => stream.DataLen, fileName => "asn1scc_<sEnc>.dat");
    end;
end if;
>>

                   

PrintMain(arrsIncludedModules, arrsVars, arrsTestFunctions, arrsUsedPackages, arrsInitCalls, bGenerateDatFile) ::= <<
WITH Ada.Text_IO;
<if(bGenerateDatFile)>
with Ada.Sequential_IO;
with Interfaces;
use type Interfaces.Unsigned_8;
<endif>
WITH <rtlModuleName()>; use type <rtlModuleName()>.Asn1UInt; use type <rtlModuleName()>.Asn1Int;use type <rtlModuleName()>.BIT;
<arrsIncludedModules:{inc| with <inc>;}; separator="\n">
<arrsIncludedModules:{inc| use <inc>;}; separator="\n">
--# inherit <rtlModuleName()>, <arrsIncludedModules; separator=", ">;
--# main_program;


FUNCTION MainProgram RETURN INTEGER
IS --# hide MainProgram
    USE Ada.Text_IO;
    <arrsUsedPackages:{p|USE <p>;}; separator="\n">
    totalErrors  : INTEGER:=0;
    <arrsVars; separator="\n">
    
<if(bGenerateDatFile)>
    PROCEDURE WRITE_STR_TO_FILE(Strm : <rtlModuleName()>.BitArray; 
			        DataLen	: Natural;
                                fileName:String) IS
      package Seq_IO is new Ada.Sequential_IO(<rtlModuleName()>.Asn1Byte);
      use Seq_IO;

      MASKS : CONSTANT <rtlModuleName()>.OctetBuffer (1 .. 8) := (16#80#, 16#40#, 16#20#, 16#10#, 16#08#, 16#04#, 16#02#, 16#01#);
      curByte:<rtlModuleName()>.Asn1Byte:=0;
      bitIndex:Integer;
      My_Out_File : Seq_IO.FILE_TYPE;
    BEGIN
      Create(My_Out_File, Out_File, fileName);

      FOR I IN 1..DataLen LOOP
         bitIndex := ((I-1) mod 8) +1;
         if bitIndex = 1 THEN
            curByte:=0;
         end if;
         if Strm(I)=1 THEN
           curByte := curByte OR MASKS(bitIndex);
         end if;
         if bitIndex = 8 OR I = DataLen THEN
            Write(My_Out_File, curByte);
         end if;
      end LOOP;

      Close(My_Out_File);
    end;

<endif>
BEGIN

    <arrsTestFunctions;separator="\n\n">

    -- used to increase statement coverage
    <arrsInitCalls; separator="\n\n">


    if totalErrors > 0 THEN
        Put_Line (Integer'Image(totalErrors) & " out of <arrsTestFunctions.Length> failed."); 
        RETURN 1;
    ELSE
        Put_Line ("All test cases (<arrsTestFunctions.Length>) run successfully."); 
        RETURN 0;
    end if;
end MainProgram;
>>

invokeTestCaseAsFunc(sFuncName) ::= <<
<sFuncName>(totalErrors);
>>


emitTestCaseAsFunc_h(sFuncName) ::= <<
procedure <sFuncName>( totalErrors : in out integer);
>>

emitTestCaseAsFunc_dummy_init(sTypeName, sFuncName, sDummyVarname) ::= <<
declare
   dummy : constant <sTypeName> := <sFuncName>;
   pragma Unreferenced (dummy);
begin null; end;
>>

emitTestCaseAsFunc(sFuncName, arrsVars, sModName, sTasName, sAmber, sEnc, bValueAssignment, sInitializeTcData, bStatic, sGenerateDatFile, arrsDummyInitStatementsNeededForStatementCoverage, sInitAmber) ::= <<
procedure <sFuncName>( totalErrors : in out integer)
is
    use Ada.Text_IO;
    result      : adaasn1rtl.test_case_result;

    <arrsVars; separator="\n">
    tc_data : <sTasName><if(bValueAssignment)> := <sInitializeTcData><endif>;
begin
    <if(arrsDummyInitStatementsNeededForStatementCoverage)>
    -- dummy statement used for calling init functions
    
    <arrsDummyInitStatementsNeededForStatementCoverage; separator="\n">
    <endif>
    --the actual initialization with the test case data is made here.
    <if(!bValueAssignment)>
    <sInitializeTcData>

    <else>
    tc_data := <sInitializeTcData>;

    <endif>
    result := <sTasName>_<sEnc>enc_dec(tc_data,"<sFuncName>");
    if NOT result.Success THEN
        case result.Step IS
            when <rtlModuleName()>.TC_VALIDATE =>
                Put_Line ("Test case '<sFuncName>' failed in validation"); 
            when <rtlModuleName()>.TC_ENCODE =>
                Put_Line ("Test case '<sFuncName>' failed in encoding");
            when <rtlModuleName()>.TC_DECODE =>
                Put_Line ("Test case '<sFuncName>' failed in decoding");
            when <rtlModuleName()>.TC_VALIDATE_DECODED =>
                Put_Line ("Test case '<sFuncName>' failed in the validation of the decoded message");
            when <rtlModuleName()>.TC_EQUAL =>
                Put_Line ("Test case '<sFuncName>' failed. Encoded and decoded messages are different");
        end case;
        Put_Line ("========================================");
        totalErrors := totalErrors + 1;
    end if;
    <sGenerateDatFile>
    
end <sFuncName>;
>>

printTestCaseFileDef(sPackageName, arrsIncludedModules, arrsTestFunctionDefs) ::= <<

WITH <rtlModuleName()>;
USE <rtlModuleName()>;
use type <rtlModuleName()>.OctetBuffer;
use type <rtlModuleName()>.BitArray;
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;

<arrsIncludedModules:{inc| WITH <inc>; USE <inc>;}; separator="\n">


PACKAGE <sPackageName> 
IS
<arrsTestFunctionDefs:{tas|<tas>}; separator="\n">

END <sPackageName>;
>>

printTestCaseFileBody(sPackageName, arrsIncludedModules, arrsTestFunctionBodies) ::= <<
-- Code automatically generated by asn1scc tool
WITH Ada.Text_IO;
WITH adaasn1rtl; use type adaasn1rtl.Asn1UInt; use type adaasn1rtl.Asn1Int;use type adaasn1rtl.BIT;

<arrsIncludedModules:{inc| WITH <inc>; USE <inc>;}; separator="\n">

use type <rtlModuleName()>.OctetBuffer;
use type <rtlModuleName()>.BitArray;
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;


PACKAGE BODY <sPackageName> IS

<arrsTestFunctionBodies:{vas|<vas>}; separator="\n\n"> 

END <sPackageName>;

>>