group c_header;

indentation(sStatement) ::=<<
    <sStatement>
>>

PrintHeaderFile(sFileNameWithNoExtUpperCase, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines, bHasEncodings) ::= <<
#ifndef GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>_H
#define GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>_H
/*
Code automatically generated by asn1scc tool
*/
#include "asn1crt.h"
<if(bHasEncodings)>
#include "asn1crt_encoding.h"

<endif>

<arrsIncludedModules:{inc| #include "<inc>.h"}; separator="\n">

#ifdef  __cplusplus
extern "C" {
#endif


<arrsTypeAssignments:{tas|<tas>}; separator="\n">

<arrsValueAssignments:{vas|<vas>}; separator="\n"> 

/* ================= Encoding/Decoding function prototypes =================
 * These functions are placed at the end of the file to make sure all types
 * have been declared first, in case of parameterized ACN encodings
 * ========================================================================= */

<arrsPrototypes:{proto|<proto>}; separator="\n"> 


#ifdef  __cplusplus
}
<arrsUtilityDefines; separator="\n">

#endif

#endif

>>

Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>

PrintValueAssignment(sTypeDecl, sName) ::= "extern const <sTypeDecl> <sName>;"


/*
C TYPES 
*/

Declare_Integer() ::="asn1SccSint"
Declare_PosInteger() ::="asn1SccUint"

Declare_Boolean() ::= "flag"
Declare_Real() ::= "asn1Real"
Declare_IA5String() ::= "char"
Declare_NumericString() ::= "char"
Declare_NullType() ::= "NullType"
Declare_ObjectIdentifier() ::= "Asn1ObjectIdentifier"

Declare_Asn1LocalTime                 	()::= "Asn1LocalTime"
Declare_Asn1UtcTime                   	()::= "Asn1UtcTime"
Declare_Asn1LocalTimeWithTimeZone     	()::= "Asn1TimeWithTimeZone"
Declare_Asn1Date                      	()::= "Asn1Date"
Declare_Asn1Date_LocalTime            	()::= "Asn1DateLocalTime"
Declare_Asn1Date_UtcTime              	()::= "Asn1DateUtcTime"
Declare_Asn1Date_LocalTimeWithTimeZone	()::= "Asn1DateTimeWithTimeZone"


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs) ::= <<
typedef <sParentType> <sTypeDefinitionName>;
<soExtraDefs>
>>





/******************************************************************************************************************************/
/***********************************       NEW TYPE DEFINITIONS    ************************************************************/
/******************************************************************************************************************************/

/***********************************       ENUMERATED    ************************************************************/

Define_new_enumerated_item(sName, nValue) ::= "<sName> = <nValue>"

Define_new_enumerated_item_macro(td/*:FE_EnumeratedTypeDefinition*/, sAsn1Name, sCName) ::= "#define <td.typeName>_<sAsn1Name> <sCName>"

Define_new_enumerated(td/*:FE_EnumeratedTypeDefinition*/, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax, arrsResolvingMacros) ::= <<
typedef enum {
    <arrsEnumNamesAndValues:{it|<it>}; separator=",\n">
} <td.typeName>;

// please use the following macros to avoid breaking code.
<arrsResolvingMacros; separator="\n">
>>



Define_subType_enumerated(td/*:FE_EnumeratedTypeDefinition*/, prTd/*:FE_EnumeratedTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       STRING    ************************************************************/

Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
typedef char <td.typeName>[<nCMax>];
>>

Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       OCTET STRING    ************************************************************/

Define_new_octet_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize) ::= <<
typedef struct {
<if(!bFixedSize)>
    int nCount; 

<endif>    
    byte arr[<nMax>];
} <td.typeName>;

>>

Define_subType_octet_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       BIT STRING    ************************************************************/
Define_new_bit_string(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, nMaxOctets) ::= <<
typedef struct {
<if(!bFixedSize)>
    int nCount; /*Number of bits in the array. Max value is : <nMax> */

<endif>    
    byte arr[<nMaxOctets>];
} <td.typeName>;
>>

Define_subType_bit_string(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

/***********************************       SEQUENCE OF    ************************************************************/


Define_new_sequence_of(td/*:FE_SizeableTypeDefinition*/, nMin, nMax, bFixedSize, sChildType, soChildDefintion) ::= <<

<soChildDefintion>

typedef struct {
<if(!bFixedSize)>
    int nCount; 

<endif>    
    <sChildType> arr[<nMax>];
} <td.typeName>;
>>



Define_subType_sequence_of(td/*:FE_SizeableTypeDefinition*/, prTd/*:FE_SizeableTypeDefinition*/, soParentTypePackage, bFixedSize) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>


/***********************************       SEQUENCE     ************************************************************/

Define_new_sequence_child_bit(sName) ::= "unsigned int <sName>:1;"
Define_new_sequence_child(sName, sType) ::= "<sType> <sName>;"

Define_new_sequence_save_pos_child(td/*:FE_SequenceTypeDefinition*/, sName, nMaxBytesInACN) ::= "BitStream <sName>;"

Define_new_sequence(td/*:FE_SequenceTypeDefinition*/, arrsChildren, arrsOptionalChildren, arrsChildldrenDefintions, arrsNullFieldsSavePos) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildldrenDefintions; separator= "\n">
<if (arrsNullFieldsSavePos)>
typedef struct {
    <arrsNullFieldsSavePos; separator="\n">
} <td.extention_function_potisions>;

<endif>
typedef struct {
    <arrsChildren; separator="\n">

    <if (arrsOptionalChildren)>
    struct {
        <arrsOptionalChildren; separator="\n">
    } exist;

    <endif>
} <td.typeName>;
>>

Define_subType_sequence(td/*:FE_SequenceTypeDefinition*/, prTd/*:FE_SequenceTypeDefinition*/, soParentTypePackage, arrsOptionalChildren) ::= <<
typedef <prTd.typeName> <td.typeName>;
<if (arrsNullFieldsSavePos)>
typedef <prTd.extention_function_potisions> <td.extention_function_potisions>;

<endif>
>>

/***********************************       CHOICE    ************************************************************/


Define_new_choice_child(sName, sType, sPresent) ::=<<
<sType> <sName>;
>>

Define_new_choice(td/*:FE_ChoiceTypeDefinition*/, sChoiceIDForNone, sFirstChildNamePresent, arrsChildren, arrsPresent, nIndexMax, arrsChildldrenDefintions) ::= <<
/*-- <td.typeName> --------------------------------------------*/
<arrsChildldrenDefintions; separator= "\n">

typedef enum {
    <sChoiceIDForNone>,
    <arrsPresent:{ch|<ch>}; separator=",\n"> 
} <td.selection>;


typedef struct {
    <td.selection> kind;
    
    union {
        <arrsChildren:{ch|<ch>}; separator="\n">
    } u; 
} <td.typeName>;
>>

Define_subType_choice(td/*:FE_ChoiceTypeDefinition*/, prTd/*:FE_ChoiceTypeDefinition*/, soParentTypePackage) ::= <<
typedef <prTd.typeName> <td.typeName>;
>>

