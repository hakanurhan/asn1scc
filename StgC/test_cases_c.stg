/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group ch ;

PrintAutomaticTestCasesHeaderFile(sFileNameWithNoExtUpperCase, sFileNameNoExt, arrsTypeAssignments) ::= <<
#ifndef GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>
#define GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>
/*
Code automatically generated by asn1scc tool
*/
#include "asn1crt.h"
#include "<sFileNameNoExt>.h"

#ifdef  __cplusplus
extern "C" {
#endif


<arrsTypeAssignments:{tas|<tas>}; separator="\n\n">



#ifdef  __cplusplus
}
#endif

#endif

>>


PrintAutomaticTestCasesSourceFile(sHeaderFileName, arrsAdditionalDecl, arrsTypeAssignments) ::= <<
/*
Code automatically generated by asn1scc tool
*/

#include \<string.h>
#include \<math.h>
#include \<limits.h>
#include \<stdio.h>
#include "asn1crt.h"
#include "<sHeaderFileName>"

<arrsAdditionalDecl: {inc|#include "<inc>.h"}; separator="\n">

<arrsTypeAssignments:{tas|<tas>}; separator="\n">

>>





/* Encode Decode start*/

ACN_UpdateParamDecl(sTasName, sStar, sParamType, sParamName, sStarParm) ::= <<
flag <sTasName>_ACN_Encode_update_<sParamName>(const <sTasName><sStar> pVal, <sParamType><sStarParm> <sParamName>);
>>

Codec_UpdateDecInParam(sTasName, sParamName) ::= <<
ret = <sTasName>_ACN_Encode_update_<sParamName>(pVal, &dec_<sParamName>);
*pErrCode = ret ? 0 : 1;
>>



Codec_Encode(sModName, sFuncName, sVal) ::= <<
// Encode value
ret = <sFuncName>(<sVal>, &bitStrm, pErrCode, TRUE);
*pErrCode = ret ? 0 : 1;
>>

Codec_Decode(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
BitStream_AttachBuffer(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
// Decode value
ret = <sFuncName>(<sAmber>decodedPDU, &bitStrm, pErrCode);
*pErrCode = ret ? 0 : 2;
>>

Codec_Decode_XER(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
ByteStream_AttachBuffer(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
// Decode value
ret = <sFuncName>(<sAmber>decodedPDU, &bitStrm, pErrCode);
*pErrCode = ret ? 0 : 2;
>>

Codec_validate_output(sModName, sFuncName, sAmber) ::= <<
// validate decoded data
ret = <sFuncName>(<sAmber>decodedPDU, pErrCode);
*pErrCode = ret ? 0 : 3;
>>

Codec_compare_input_with_output(sModName, sFuncName, sVal, sAmber) ::= <<
ret = <sFuncName>(<sVal>, <sAmber>decodedPDU);
*pErrCode = ret ? 0 : 4;
>>

Codec_write_bitstreamToFile() ::= <<
char buf[1024];
strcpy(buf, filename);
FILE* fp = fopen(strcat(buf,".dat"), "wb");
fwrite(bitStrm.buf, 1, bitStrm.count, fp);
fclose(fp);
>>

JoinItems(sPart, soNestedPart) ::= <<
<sPart>
<if(soNestedPart)>
if (ret) {
    <soNestedPart>
}

<endif>
>>


Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
<sType> enc_<sPrmName> = <sPrmValue>;
<sType> dec_<sPrmName>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "<sType> dec_<sPrmName>;"


PrintCodec_body_header(sFuncName, sModName, sTasName, sStar, sVal) ::= <<
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename);
>>

PrintCodec_body(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename)
{
    static <sTasName> decodedPDU;
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; /* +1 for zerosized types */
    BitStream bitStrm;
    flag ret = TRUE;

    BitStream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    <sNestedStatements>
    return ret;
}
>>

PrintCodec_body_XER(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
flag <sFuncName>(const <sTasName><sStar> <sVal>, int* pErrCode, const char* filename)
{
    static <sTasName> decodedPDU;
    static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; /* +1 for zerosized types */
    ByteStream bitStrm;
    flag ret = TRUE;

    ByteStream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);
    <sNestedStatements>
    return ret;
}
>>






/* Encode Decode End*/


PrintMain(sTestSuiteFilename) ::= <<
#include \<stdio.h>

#include "<sTestSuiteFilename>.h"

static void printf_tests_failed(int testCount, int failedCount)
{
    printf("%d out of %d failed.\n", failedCount, testCount);
}

static void printf_tests_passed(int testCount)
{
    printf("All test cases (%d) run successfully.\n", testCount);
}

static void printf_null()
{
}

static void printf_null_char(const char* s)
{
    (void)s;
}

static void printf_message(const char* message)
{
    printf("%s\n", message);
}

int main(int argc, char* argv[])
{
    (void)argc;
    (void)argv;

    TestOutput output = {
               .report_tests_failed = printf_tests_failed,
               .report_all_tests_passed = printf_tests_passed,
               .report_suite_begin = printf_null,
               .report_suite_end = printf_null,
               .report_case_begin = printf_null_char,
               .report_case_end = printf_null,
               .report_failure_begin = printf_null,
               .report_failure_end = printf_null,
               .report_failure_message = printf_message
    };

    return asn1scc_run_generated_testsuite(&output);
}

>>

/*
Code calling a test case
*/                    
PrintSuite_call_codec(sModName, sTasName, sAmber, sEnc, sValue, sValueAsAsn1, sVasName, bStatic, sGenerateDatFile, soInitFunction, sInitAmber) ::= <<
{
    output->report_case_begin("<sTasName>_<sEnc>enc_dec");
    <if(soInitFunction)>
    {
        // dummy statement used for calling init functions
        <if(bStatic)>static <endif><sTasName> tmp0;
        <soInitFunction>(<sInitAmber>tmp0);
    }

    <endif>
    <if(bStatic)>static <endif><sTasName> tmp =
        <sValue>;
        result = <sTasName>_<sEnc>enc_dec(<sAmber>tmp, &errCode);
        if (!result) {
           output->report_failure_begin();

           switch(errCode)
           {
           case 1:
                output->report_failure_message("Test case <sVasName> failed in encoding.");
                break;
           case 2:
                output->report_failure_message("Test case '<sVasName>' failed in decoding.");
                break;
           case 3:
                output->report_failure_message("Test case '<sVasName>' failed in the validation of the decoded message.");
                break;
           case 4:
                output->report_failure_message("Test case '<sVasName>' failed. Encoded and decoded messages are different.");
                break;
           default:
                output->report_failure_message("Unexpected error code in test case '<sVasName>'.");
           }
           output->report_failure_message("Test case index was <sValueAsAsn1>");
           output->report_failure_message("========================================");
           totalErrors = totalErrors + 1;

           output->report_failure_end();
        }
    <sGenerateDatFile>

    output->report_case_end();
}
>>





PrintSuite_call_codec_generate_dat_file(sModName, sTasName, sAmber, sEnc, sStreamName) ::= <<
	if (result) {
		static byte encBuff[<sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING + 1]; /* +1 for zerosized types */
		<sStreamName>Stream bitStrm;
		FILE* fp;

  		<sStreamName>Stream_Init(&bitStrm, encBuff, <sTasName>_REQUIRED_BYTES_FOR_<sEnc>ENCODING);

		result = <sTasName>_<sEnc>Encode(<sAmber>tmp, &bitStrm, &errCode, TRUE);
		fp = fopen("asn1scc_<sEnc>.dat","wb");

		if (fp==NULL) 
		{
			printf("fopen failed !!!\n");
			return 2;
		}

	
		fwrite(encBuff,1,(size_t)<sStreamName>Stream_GetLength(&bitStrm),fp);
		fclose(fp);
	};
>>


PrintTestSuiteHeader() ::= <<
#ifndef GENERATED_ASN1SCC_TESTSUITE_H
#define GENERATED_ASN1SCC_TESTSUITE_H

#ifdef  __cplusplus
extern "C" {
#endif

typedef struct {
    void (*report_tests_failed)(int testsCount, int failedCount);
    void (*report_all_tests_passed)(int testsCount);

    void (*report_suite_begin)();
    void (*report_suite_end)();

    void (*report_case_begin)(const char* caseName);
    void (*report_case_end)();

    void (*report_failure_begin)();
    void (*report_failure_end)();
    void (*report_failure_message)(const char* message);
} TestOutput;

int asn1scc_run_generated_testsuite(TestOutput* output);

#ifdef  __cplusplus
}
#endif


#endif // GENERATED_ASN1SCC_TESTSUITE_H

>>

PrintTestSuiteSource(sTestSuiteFilename, arrsIncludedModules, arrsVars, arrsTestFunctions) ::= <<
#include "<sTestSuiteFilename>.h"

#include \<stdio.h>
#include \<string.h>
#include \<math.h>
#include \<float.h>
#include \<limits.h>

#include "asn1crt.h"

<arrsIncludedModules:{inc| #include "<inc>.h"}; separator="\n">

int asn1scc_run_generated_testsuite(TestOutput* output)
{
    int totalErrors = 0;
    <arrsVars; separator="\n">


    output->report_suite_begin();

    <arrsTestFunctions;separator="\n\n">

    output->report_suite_end();

    if (totalErrors > 0 ) {
        output->report_tests_failed(<arrsTestFunctions.Length>, totalErrors);
        return 1;
    } else {
        output->report_all_tests_passed(<arrsTestFunctions.Length>);
        return 0;
    }
}

>>



invokeTestCaseAsFunc(sFuncName) ::= <<
<sFuncName>(output, &totalErrors);
>>


emitTestCaseAsFunc_h(sFuncName) ::= <<
void <sFuncName>(const TestOutput* output, int *totalErrors);
>>

emitTestCaseAsFunc_dummy_init(sTypeName, sFuncName, sDummyVarname) ::= <<
<sFuncName>(<sDummyVarname>);
>>

emitTestCaseAsFunc(sFuncName, arrsVars, sModName, sTasName, sAmber, sEnc, bValueAssignment, sInitializeTcData, bStatic, sGenerateDatFile, arrsDummyInitStatementsNeededForStatementCoverage, sInitAmber) ::= <<
void <sFuncName>(const TestOutput* output, int *totalErrors)
{
    flag result;
    int errCode;
    <arrsVars; separator="\n">

    output->report_case_begin("<sFuncName>");
    <if(arrsDummyInitStatementsNeededForStatementCoverage)>
    {
        // dummy statement used for calling init functions
        <if(bStatic)>        static <endif><sTasName> tmp0;
        <arrsDummyInitStatementsNeededForStatementCoverage; separator="\n">
    }

    <endif>
    <if(bStatic)>    static <endif><sTasName> tc_data<if(bValueAssignment)> = <else>; <endif>
    <sInitializeTcData><if(bValueAssignment)>;<endif>

    result = <sTasName>_<sEnc>enc_dec(<sAmber>tc_data, &errCode, "<sFuncName>");
    if (!result) {
        output->report_failure_begin();

        switch(errCode)
        {
        case 1:
            output->report_failure_message("Test case <sFuncName> failed in encoding.");
            break;
        case 2:
            output->report_failure_message("Test case '<sFuncName>' failed in decoding.");
            break;
        case 3:
            output->report_failure_message("Test case '<sFuncName>' failed in the validation of the decoded message.");
            break;
        case 4:
            output->report_failure_message("Test case '<sFuncName>' failed. Encoded and decoded messages are different.");
            break;
        default:
            output->report_failure_message("Unexpected error code in test case '<sFuncName>'.");
        }
        output->report_failure_message("========================================");
        *totalErrors = (*totalErrors) + 1;

        output->report_failure_end();
    }
    <sGenerateDatFile>

    output->report_case_end();
}
>>


printTestCaseFileDef(sThisFile, arrsIncludedModules, arrsTestFunctionDefs) ::= <<

#ifndef GENERATED_ASN1SCC_<sThisFile>_H
#define GENERATED_ASN1SCC_<sThisFile>_H
/*
Code automatically generated by asn1scc tool
*/
#include "asn1crt.h"
#include "testsuite.h"
<arrsIncludedModules:{inc| #include "<inc>"}; separator="\n">

#ifdef  __cplusplus
extern "C" {
#endif
<arrsTestFunctionDefs;separator="\n\n">

#ifdef  __cplusplus
}

#endif

#endif

>>

    
printTestCaseFileBody(sThisFile, arrsIncludedModules, arrsTestFunctionBodies) ::= <<
#include "<sThisFile>.h"

#include \<stdio.h>
#include \<string.h>
#include \<math.h>
#include \<float.h>
#include \<limits.h>
#include "asn1crt.h"

<arrsIncludedModules:{inc| #include "<inc>"}; separator="\n">

<arrsTestFunctionBodies;separator="\n\n">

>>


